/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  BasicMouse1                            */
/*      FILE         :  BasicMouse1.c                          */
/*      DESCRIPTION  :  Main Program                           */
/*      CPU SERIES   :  SH-2                                   */
/*      CPU TYPE     :  SH7125                                 */
/*                                                             */
/*      This file is generated by e2 studio.                   */
/*                                                             */
/***************************************************************/

#include "iodefine.h"
#include "stdarg.h"
#include "serial.h"
#include "math.h"
#include "init.h"

//#include "workshop.h"
#include "hensuu&define.h"
#include "adachihou.h"
#include "hidaritehou.h"

//#define  motor_enable PE.DRL.BIT.B8
//#define LED1_p PB.DR.BIT.B1
//#define LED2_y PB.DR.BIT.B2
//#define LED3_r PB.DR.BIT.B3
//
//#define pi 3.141592
//#define r_tire 25.96
//#define l_tire 25.92
//#define R_tread /*44.2*/43.65
//#define r_tire_control_ON 25.96
//#define l_tire_control_ON 25.92
//
//#define SEN_r_ref 600
//#define SEN_l_ref 540
//#define r_threshold 200
//#define l_threshold 250
//#define r_front_threshold
//#define l_front_threshold
//#define DIFF_THRESHOLD 2
//#define Kp_r 0.12//0.15
//#define Kp_l 0.12//0.15
//#define Kp_center 0.15
//#define r_wall_judge 180
//#define l_wall_judge 250
//#define r_front_wall_judge 80
//#define l_front_wall_judge
//#define x_size 15
//#define y_size 15
//#define goal_x 4
//#define goal_y 4
////#define V_FAST 2000
////#define ACCEL_FAST 3000
////#define V_search 480
////#define ACCEL_search 2000
//#define STOP_count 180
////#define V_path 500
////#define ACCEL_path 2000
////#define STOP_count_pat 150

volatile int SEN, SEN_l_value, SEN_l_front_value, SEN_r_front_value,
		SEN_r_value, SEN_r_diff, SEN_l_diff, SEN_r_old_value, SEN_l_old_value,
		wall_control, SEN_l_front_value_ON, SEN_r_front_value_ON,
		SEN_l_value_ON, SEN_r_value_ON, SEN_l_front_value_OFF,
		SEN_r_front_value_OFF, SEN_l_value_OFF, SEN_r_value_OFF, sen_count = 0,
		mode_count = 0, direction_count = 0, x, y, Wall_Judge,
		watched_Wall_Judge, Mark_Judge, j = 0, xj, yj, i = 0, k = 0, l = 0,
		direction_number, s_count, test1 = 0, clash_count = 0, p_i = 0,
		kabe_cancel;
volatile unsigned long cmt_count = 0;
volatile float Battery, speed = 0.0, speed_r, speed_l, accel = 500.0, angacc =
		0.0, omega = 0.0, angle = 0.0, speed_relative, speed_turn, total_dist,
		TGRA_r, TGRA_l, Error, Control, r_sen_thredhold, l_sen_thredhold;
volatile unsigned short colum[15] = { 0 }, row[15] = { 0 }, colum_watched[15] = { 0 } , row_watched[15] = { 0 }, colum2[15] = { 0 }, row2[15] = { 0 },
		colum_watched2[15] = { 0 }, row_watched2[15] = { 0 }, remove_row = 0,remove_colum = 0, q_s[257], q_v[257];
volatile unsigned char renewal_flag = 0, accident_flag = 0, q[257], map[16][16],
		map2[16][16], footmark[16][16] = { 0 }, straight_count = 0, /*vector_map[16][16],*/
		straight_flag[16][16] = { 0 }, straight_map[16][16] = { 0 },
		flag_kabekire = 0, qx, qy, interrupt_kabekire = 0, count_kabekire_r = 1,
		pass[200], last_p_i, con_p_i, read_p_i, d_i = 0; // 区画の座標(0～255)を入れる配列 左下0、右下15、左上240、右上255
volatile short head, tail;          // 先頭位置, 末尾位置
volatile unsigned short int node_colum[16][16], node_row[16][16],
		node_dist_colum[16][16], node_dist_row[16][16], node_center[16][16];

void initCPU(void);
void init_sci(void);
void initAD(void);
void initCMT(void);
void initMTU(void);
void wait(int hikisuu);
void turn(float hikisuu_angle, float vmax2, float hikisuu_accel2);
void sen_AD_convert(void);
void Battery_AD_convert(void);
void maze_display();
void node_map_display();
void walkmap_display();
void walkmap2_display();
void footmark_display();
void straight_display();
void mode_select(void);
void task_select(void);
void sen_AD_display(void);
//void hidaritehou2(void);

void direction_xy(void);

void add_wall_front(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count);
void add_wall_right(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count);
void add_wall_left(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count);
void watched_wall_front(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count);
void add_wall_front_2(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count);
void add_wall_right_2(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count);
void add_wall_left_2(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count);

void watched_wall_front_2(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count);
void watched_wall_right_2(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count);
void watched_wall_left_2(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count);
void setReached(char hikisuu_x, char hikisuu_y);
int hasReached(char hikisuu_x, char hikisuu_y);
int is_Exist_Wall(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count);
int is_Exist_Wall_2(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count);
int is_the_Wall_watched(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count);
int is_the_Wall_watched_2(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count);
void Q_node_map_maker(int hikisuu_start_x, int hikisuu_start_y);
void q_walk_map_maker(int hikisuu_goal_x, int hikisuu_goal_y);
void q_NOT_short_map_maker(int hikisuu_goal_x, int hikisuu_goal_y);
void q_vector_map_maker(int hikisuu_goal_x, int hikisuu_goal_y);
void q_dual_map_maker(int hikisuu_goal_x, int hikisuu_goal_y);
void MAP_INFORMATION_convert();
void WALL_INFORMATION_convert();
void WALL_INFORMATION_1_to_2();
void WATCHED_WALL_INFORMATION_convert();
void unknown_WALL_add();
void unknown_WALL_remove();

void adachihou_q2_slalom(int hikisuu_goal_x, int hikisuu_goal_y, int start_x,
		int start_y, int V_search, int ACCEL_search, float hikisuu_angacc,
		float hikisuu_angle1_r, float hikisuu_angle2_r, float hikisuu_angle1_l,
		float hikisuu_angle2_l, float offset_r1, float offset_r2,
		float offset_l1, float offset_l);
void make_pass(int hikisuu_goal_x, int hikisuu_goal_y);
void convert_pass();
void read_pass(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel);
void read_pass_b(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel);
void adachihou_q(int hikisuu_goal_x, int hikisuu_goal_y, int start_x,
		int start_y);
void adachihou_q2(int hikisuu_goal_x, int hikisuu_goal_y, int start_x,
		int start_y, int V_search, int ACCEL_search);
void hurukawahou_q2(int hikisuu_goal_x, int hikisuu_goal_y, int start_x,
		int start_y);
void adachihou_straight_count(int hikisuu_goal_x, int hikisuu_goal_y);

void distance4(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
		float vterm, int kabeseigyo);
void distance3(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
		float vterm, int kabeseigyo);
void slalom_R(float hikisuu_angle, float omega_max, float hikisuu_angacc,
		float v_turn, float omega_term, float offset, int kabeseigyo);
void slalom_L(float hikisuu_angle, float omega_max, float hikisuu_angacc,
		float v_turn, float omega_term, float offset, int kabeseigyo);
void slalom_R2(float hikisuu_angle, float hikisuu_angacc, float angle1,
		float angle2, float v_turn, float offset1, float offset2,
		int kabeseigyo);
void slalom_L2(float hikisuu_angle, float hikisuu_angacc, float angle1,
		float angle2, float v_turn, float offset1, float offset2,
		int kabeseigyo);
void distance_q(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
		float vterm, int kabeseigyo);
void turn_clock3(float hikisuu_angle, float vmax2, float hikisuu_accel2,
		float v_0_2, float vterm2);
void turn_unclock3(float hikisuu_angle, float vmax2, float hikisuu_accel2,
		float v_0_2, float vterm2);

void interrupt_mtu2_0_tgib0();
void interrupt_mtu2_1_tgib1();
void interrupt_cmt0();
void interrupt_cmt1();

void initCPU(void) {
	CPG.FRQCR.BIT.IFC = 1;                //Iφ / 2 = 50Mhz(初期値/4)
}

void interrupt_mtu2_0_tgib0() {	//right motor
	MTU20.TSR.BIT.TGFB = 0;		//フラグクリア
	MTU20.TGRA = TGRA_r;
}

void interrupt_mtu2_1_tgib1() {	//left motor
	MTU21.TSR.BIT.TGFB = 0;		//フラグクリア
	MTU21.TGRA = TGRA_l;
}

void sen_AD_convert() {
	PA.DRL.BIT.B13 = 0;
	PA.DRL.BIT.B14 = 0;
	PA.DRL.BIT.B12 = 0;
	PA.DRL.BIT.B15 = 0;

//	for (sen_count = 0; sen_count < 400; sen_count++) {
//	}

	AD1.ADCR.BIT.ADST = 0;
	AD1.ADCSR.BIT.CH = 1;
	AD1.ADCR.BIT.ADST = 1;
	while (AD1.ADCSR.BIT.ADF == 0)
		;
	AD1.ADCSR.BIT.ADF = 0;
	SEN_l_value_OFF = AD1.ADDR5 >> 6;
	AD1.ADCR.BIT.ADST = 0;
	AD1.ADCSR.BIT.CH = 2;
	AD1.ADCR.BIT.ADST = 1;
	while (AD1.ADCSR.BIT.ADF == 0)
		;
	AD1.ADCSR.BIT.ADF = 0;
	SEN_r_value_OFF = AD1.ADDR6 >> 6;

	AD1.ADCR.BIT.ADST = 0;		//以下AD変換
	AD1.ADCSR.BIT.CH = 0;
	AD1.ADCR.BIT.ADST = 1;
	while (AD1.ADCSR.BIT.ADF == 0)
		;
	AD1.ADCSR.BIT.ADF = 0;

	SEN_l_front_value_OFF = AD1.ADDR4 >> 6;
	AD1.ADCR.BIT.ADST = 0;
	AD1.ADCSR.BIT.CH = 3;
	AD1.ADCR.BIT.ADST = 1;
	while (AD1.ADCSR.BIT.ADF == 0)
		;
	AD1.ADCSR.BIT.ADF = 0;
	SEN_r_front_value_OFF = AD1.ADDR7 >> 6;

	PA.DRL.BIT.B13 = 1;		//以下センサのAD変換
	PA.DRL.BIT.B14 = 1;
	PA.DRL.BIT.B12 = 0;
	PA.DRL.BIT.B15 = 0;

	for (sen_count = 0; sen_count < 1200; sen_count++) {
	}

	AD1.ADCR.BIT.ADST = 0;
	AD1.ADCSR.BIT.CH = 2;
	AD1.ADCR.BIT.ADST = 1;
	while (AD1.ADCSR.BIT.ADF == 0)
		;
	AD1.ADCSR.BIT.ADF = 0;
	SEN_r_value_ON = AD1.ADDR6 >> 6;

	AD1.ADCR.BIT.ADST = 0;
	AD1.ADCSR.BIT.CH = 1;
	AD1.ADCR.BIT.ADST = 1;
	while (AD1.ADCSR.BIT.ADF == 0)
		;
	AD1.ADCSR.BIT.ADF = 0;
	SEN_l_value_ON = AD1.ADDR5 >> 6;

	PA.DRL.BIT.B12 = 1;
	PA.DRL.BIT.B15 = 1;
	PA.DRL.BIT.B13 = 0;
	PA.DRL.BIT.B14 = 0;

	for (sen_count = 0; sen_count < 1200; sen_count++) {
	}

	AD1.ADCR.BIT.ADST = 0;
	AD1.ADCSR.BIT.CH = 0;
	AD1.ADCR.BIT.ADST = 1;
	while (AD1.ADCSR.BIT.ADF == 0)
		;
	AD1.ADCSR.BIT.ADF = 0;
	SEN_l_front_value_ON = AD1.ADDR4 >> 6;

	AD1.ADCR.BIT.ADST = 0;
	AD1.ADCSR.BIT.CH = 3;
	AD1.ADCR.BIT.ADST = 1;
	while (AD1.ADCSR.BIT.ADF == 0)
		;
	AD1.ADCSR.BIT.ADF = 0;
	SEN_r_front_value_ON = AD1.ADDR7 >> 6;

	SEN_l_front_value = SEN_l_front_value_ON - SEN_l_front_value_OFF;
	SEN_r_front_value = SEN_r_front_value_ON - SEN_r_front_value_OFF;
	SEN_l_value = SEN_l_value_ON - SEN_l_value_OFF;
	SEN_r_value = SEN_r_value_ON - SEN_r_value_OFF;

	PA.DRL.BIT.B13 = 0;
	PA.DRL.BIT.B14 = 0;
	PA.DRL.BIT.B12 = 0;
	PA.DRL.BIT.B15 = 0;
}
void Battery_AD_convert() {
	initAD();
	AD0.ADCR.BIT.ADST = 0;	//BatteryのAD変換
	AD0.ADCSR.BIT.CH = 0;
	AD0.ADCR.BIT.ADST = 1;
	while (AD0.ADCSR.BIT.ADF == 0)
		;
	AD0.ADCSR.BIT.ADF = 0;

	SEN = AD0.ADDR0 >> 6;
	Battery = 5.0 * 151.0 / 51.0 * SEN / 1024.0;
}

void wait(int hikisuu) {
	cmt_count = 0;
	while (cmt_count <= hikisuu) {
	}
}
void sen_AD_display() {
	while (1) {					//センサAD変換
		PB.DR.BIT.B1 = 1;

		myprintf("kabocha\n\r");

		myprintf(
				"センサ右=%d\n\r,センサ右前=%d\n\r,センサ左前=%d\n\r,センサ左=%d\n\r,変化値ｒ=%d\n\r,変化値l=%d\n\r,old_r=%d\n\r",
				SEN_r_value, SEN_r_front_value, SEN_l_front_value, SEN_l_value,
				SEN_r_diff, SEN_l_diff, SEN_r_old_value);

		wait(100);
	}
}
void maze_display() {
//		for (j = 0; j <= 15; j++) {
//					myprintf("|   ");
//				}
//		myprintf("|\n\r");
//		for (j = 0; j <= 14; j++) {
//			myprintf("---+");
//		}
//		myprintf("---\n\r");

	myprintf("+");
	for (j = 0; j <= 14; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

	for (yj = 15; yj > 0; yj--) {
		myprintf("|   ");
		for (xj = 1; xj <= 15; xj++) {
			if (is_Exist_Wall(xj, yj, 3) == 1) {
				myprintf("|   ");
			} else {
				myprintf("    ");
			}
		}
		myprintf("|\n\r");

		for (xj = 0; xj <= 15; xj++) {
			if (is_Exist_Wall(xj, yj, 2) == 1) {
				myprintf("+---");
			} else {
				myprintf("+   ");
			}
		}
		myprintf("+\n\r");
	}
	myprintf("|   ");
	for (xj = 1; xj <= 15; xj++) {
		if (is_Exist_Wall(xj, yj - 1, 3) == 1) {
			myprintf("|   ");
		} else {
			myprintf("    ");
		}
	}
	myprintf("|\n\r");

	myprintf("+");
	for (j = 0; j <= 14; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");
//	for(j=0;j<=15;j++){
//	if(Exist_Wall==1){
//
//		}
//
//	}
}
void node_map_display() {
	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("-----+");
	}
	myprintf("-----+\n\r");

	for (yj = y_size; yj > 0; yj--) {
		myprintf("|");
		myprintf("\x1b[32m");
		myprintf("%3d", node_center[0][yj]);
		myprintf("\x1b[39m");
		for (xj = 1; xj <= x_size; xj++) {

			if (is_Exist_Wall(xj, yj, 3) == 1) {	//西壁を読む
				myprintf("  |");
			} else {
				myprintf("%3d", node_colum[xj][yj]);	//←できてるか怪しすぎる…
			}
			myprintf("\x1b[32m");
			myprintf("%3d", node_center[xj][yj]);
			myprintf("\x1b[39m");
		}
		myprintf("  |\n\r");

		for (xj = 0; xj <= x_size; xj++) {
			if (is_Exist_Wall(xj, yj, 2) == 1) {	//	南壁読む
				myprintf("+-----");
			} else {
				myprintf("\x1b[35m");
				myprintf("+%3d  ", node_row[xj][yj]);
				myprintf("\x1b[39m");
			}
		}
		myprintf("+\n\r");
	}
	myprintf("|");	//
	myprintf("%3d", node_center[0][0]);
	for (xj = 1; xj <= x_size; xj++) {
		if (is_Exist_Wall(xj, 0, 3) == 1) {
			myprintf("  |");
		} else {
			myprintf("%3d", node_colum[xj][0]);	//←できてるか怪しすぎる…
		}
		myprintf("\x1b[32m");
		myprintf("%3d", node_center[xj][0]);
		myprintf("\x1b[39m");
	}
	myprintf("  |\n\r");

	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("-----+");
	}
	myprintf("-----+\n\r");
	myprintf("node_colum[1][0]=%d\n\r",node_colum[1][0]);
	myprintf("node_colum[1][1]=%d\n\r",node_colum[1][1]);
	myprintf("node_colum[2][0]=%d\n\r",node_colum[2][0]);
	myprintf("yj=%d\n\r",yj);

}
void walkmap_display() {
	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

	for (yj = y_size; yj > 0; yj--) {
		myprintf("|");
		myprintf("%3d", map[0][yj]);
		for (xj = 1; xj <= x_size; xj++) {

			if (is_Exist_Wall(xj, yj, 3) == 1) {	//西壁を読む
				myprintf("|");
			} else {
				myprintf(" ");
			}
			myprintf("%3d", map[xj][yj]);
		}
		myprintf("|\n\r");

		for (xj = 0; xj <= x_size; xj++) {
			if (is_Exist_Wall(xj, yj, 2) == 1) {
				myprintf("+---");
			} else {
				myprintf("+   ");
			}
		}
		myprintf("+\n\r");
	}
	myprintf("|");
	myprintf("%3d", map[0][0]);
	for (xj = 1; xj <= x_size; xj++) {
		if (is_Exist_Wall(xj, 0, 3) == 1) {
			myprintf("|");
		} else {
			myprintf(" ");
		}
		myprintf("%3d", map[xj][0]);
	}
	myprintf("|\n\r");

	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

}
void walkmap2_display() {
	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

	for (yj = y_size; yj > 0; yj--) {
		myprintf("|");
		myprintf("%3d", map2[0][yj]);
		for (xj = 1; xj <= x_size; xj++) {

			if (is_Exist_Wall_2(xj, yj, 3) == 1) {	//西壁を読む
				myprintf("|");
			} else {
				myprintf(" ");
			}
			myprintf("%3d", map2[xj][yj]);
		}
		myprintf("|\n\r");

		for (xj = 0; xj <= x_size; xj++) {
			if (is_Exist_Wall_2(xj, yj, 2) == 1) {
				myprintf("+---");
			} else {
				myprintf("+   ");
			}
		}
		myprintf("+\n\r");
	}
	myprintf("|");
	myprintf("%3d", map2[0][0]);
	for (xj = 1; xj <= x_size; xj++) {
		if (is_Exist_Wall_2(xj, 0, 3) == 1) {
			myprintf("|");
		} else {
			myprintf(" ");
		}
		myprintf("%3d", map2[xj][0]);
	}
	myprintf("|\n\r");

	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

}

void footmark_display() {
	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

	for (yj = y_size; yj > 0; yj--) {
		myprintf("|");
		myprintf("%3d", footmark[0][yj]);
		for (xj = 1; xj <= x_size; xj++) {

			if (is_Exist_Wall(xj, yj, 3) == 1) {	//西壁を読む
				myprintf("|");
			} else {
				myprintf(" ");
			}
			myprintf("%3d", footmark[xj][yj]);
		}
		myprintf("|\n\r");

		for (xj = 0; xj <= x_size; xj++) {
			if (is_Exist_Wall(xj, yj, 2) == 1) {
				myprintf("+---");
			} else {
				myprintf("+   ");
			}
		}
		myprintf("+\n\r");
	}
	myprintf("|");
	myprintf("%3d", footmark[0][0]);
	for (xj = 1; xj <= x_size; xj++) {
		if (is_Exist_Wall(xj, 0, 3) == 1) {
			myprintf("|");
		} else {
			myprintf(" ");
		}
		myprintf("%3d", footmark[xj][0]);
	}
	myprintf("|\n\r");

	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

}

void straight_display() {
	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

	for (yj = y_size; yj > 0; yj--) {
		myprintf("|");
		myprintf("%3d", straight_map[0][yj]);
		for (xj = 1; xj <= x_size; xj++) {

			if (is_Exist_Wall(xj, yj, 3) == 1) {	//西壁を読む
				myprintf("|");
			} else {
				myprintf(" ");
			}
			myprintf("%3d", straight_map[xj][yj]);
		}
		myprintf("|\n\r");

		for (xj = 0; xj <= x_size; xj++) {
			if (is_Exist_Wall(xj, yj, 2) == 1) {
				myprintf("+---");
			} else {
				myprintf("+   ");
			}
		}
		myprintf("+\n\r");
	}
	myprintf("|");
	myprintf("%3d", straight_map[0][0]);
	for (xj = 1; xj <= x_size; xj++) {
		if (is_Exist_Wall(xj, 0, 3) == 1) {
			myprintf("|");
		} else {
			myprintf(" ");
		}
		myprintf("%3d", straight_map[xj][0]);
	}
	myprintf("|\n\r");

	myprintf("+");
	for (j = 0; j <= x_size - 1; j++) {
		myprintf("---+");
	}
	myprintf("---+\n\r");

}

void mode_select() {
	mode_count = 0;
	PA.DRL.BIT.B12 = 1;
	PA.DRL.BIT.B13 = 0;
	PA.DRL.BIT.B14 = 0;
	PA.DRL.BIT.B15 = 1;
	while (1) {
		if (PE.DRL.BIT.B11 == 0 && mode_count == 0) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 0;
			PA.DRL.BIT.B13 = 0;
			PA.DRL.BIT.B14 = 0;
			PA.DRL.BIT.B15 = 0;
			LED1_p = 1;
			LED2_y = 0;
			LED3_r = 0;
			mode_count = 1;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 1) {
			for (k = 0; k <= 700000; k++) {
			}
			LED1_p = 0;
			LED2_y = 1;
			LED3_r = 0;
			mode_count = 2;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 2) {
			for (k = 0; k <= 700000; k++) {
			}
			LED1_p = 0;
			LED2_y = 0;
			LED3_r = 1;
			mode_count = 3;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 3) {
			for (k = 0; k <= 700000; k++) {
			}
			LED1_p = 1;
			LED2_y = 1;
			LED3_r = 0;
			mode_count = 4;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 4) {
			for (k = 0; k <= 700000; k++) {
			}
			LED1_p = 0;
			LED2_y = 1;
			LED3_r = 1;
			mode_count = 5;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 5) {
			for (k = 0; k <= 700000; k++) {
			}
			LED1_p = 1;
			LED2_y = 1;
			LED3_r = 1;
			mode_count = 6;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 6) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 1;
			PA.DRL.BIT.B13 = 0;
			PA.DRL.BIT.B14 = 0;
			PA.DRL.BIT.B15 = 0;
			mode_count = 7;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 7) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 0;
			PA.DRL.BIT.B13 = 1;
			PA.DRL.BIT.B14 = 0;
			PA.DRL.BIT.B15 = 0;
			mode_count = 8;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 8) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 0;
			PA.DRL.BIT.B13 = 0;
			PA.DRL.BIT.B14 = 1;
			PA.DRL.BIT.B15 = 0;
			mode_count = 9;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 9) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 0;
			PA.DRL.BIT.B13 = 0;
			PA.DRL.BIT.B14 = 0;
			PA.DRL.BIT.B15 = 1;
			mode_count = 10;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 10) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 1;
			PA.DRL.BIT.B13 = 1;
			PA.DRL.BIT.B14 = 0;
			PA.DRL.BIT.B15 = 0;
			mode_count = 11;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 11) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 1;
			PA.DRL.BIT.B13 = 0;
			PA.DRL.BIT.B14 = 1;
			PA.DRL.BIT.B15 = 0;
			mode_count = 12;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 12) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 1;
			PA.DRL.BIT.B13 = 0;
			PA.DRL.BIT.B14 = 0;
			PA.DRL.BIT.B15 = 1;
			mode_count = 13;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 13) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 0;
			PA.DRL.BIT.B13 = 1;
			PA.DRL.BIT.B14 = 1;
			PA.DRL.BIT.B15 = 0;
			mode_count = 14;
		} else if (PE.DRL.BIT.B11 == 0 && mode_count == 14) {
			mode_count = 0;
		} else if (PE.DRL.BIT.B10 == 0) {
			for (k = 0; k <= 700000; k++) {
			}
			PA.DRL.BIT.B12 = 0;
			PA.DRL.BIT.B13 = 0;
			PA.DRL.BIT.B14 = 0;
			PA.DRL.BIT.B15 = 0;
			LED1_p = 0;
			LED2_y = 0;
			LED3_r = 0;
			break;
		}
	}
}

void task_select() {

	switch (mode_count) {
	case 1://プチコン用。往復の足立法からのパス生成
		adachihou_q2_slalom(goal_x, goal_y, 0, 0, 480, 2000, 4300, 30.5, 59.5,
				30.5, 59.5, 6.0, 9.0, 6.0 + 5.5, 6.0); //スラローム調整用
//		MAP_INFORMATION_convert();	←これが災いのもと
		WALL_INFORMATION_convert();
		WATCHED_WALL_INFORMATION_convert();
		wait(2000);
		motor_enable = 1;
		wait(300); 			//励磁直後は少し待つ！
		turn_clock3(180.0, 480, 2000.0, 150.0, 150.0);
		if (direction_count == 0) {		//方向反転！
			direction_count = 2;
		} else if (direction_count == 1) {
			direction_count = 3;
		} else if (direction_count == 2) {
			direction_count = 0;
		} else {
			direction_count = 1;
		}
//		direction_xy();		//スタート方向に初期値＋1する
		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		wait(300); 			//励磁直後は少し待つ！
		motor_enable = 0;
		adachihou_q2_slalom(0, 0, goal_x, goal_y, 480, 2000, 4300, 30.5, 59.5,
				30.5, 59.5, 6.0, 9.0, 6.0 + 5.5, 6.0); //スラローム調整用

		LED2_y = 1;
		WALL_INFORMATION_convert();
		WATCHED_WALL_INFORMATION_convert();
		unknown_WALL_add();

		q_walk_map_maker(goal_x, goal_y);		//更新して作り直した迷路状法をもとに歩数マップを作成
		make_pass(goal_x, goal_y);		//行動の確認
		convert_pass();		//ぱすを大廻化
		LED2_y = 0;

//		l = 480;
////		motor_enable = 1;
////		wait(300); 			//励磁直後は少し待つ！
////		hidaritehou_slalom(goal_x, goal_y, 480, 2000, 4300, 27, 63, 4);
//		motor_enable = 1;
//		wait(300); 			//励磁直後は少し待つ！
//		distance3(180, l, 2500, 150, l, 0);
//		total_dist = 0;
//		while (i != 14) {
//			i++;
//			total_dist = 0;
//			interrupt_kabekire = 1;
//			slalom_R2(90, 4300, 30.5, 59.5, 480, 5.0, 9.0, 1);
////			distance3(180, 480, 2500, 480, 480, 0);
//		}
////		slalom_L2(90, 4300, 30.5, 59.5, 480, 7.5, 0);
//		distance3(180, l, 2500, l, 150, 0);
//		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
//		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
//		wait(300); 			//励磁直後は少し待つ！
//		motor_enable = 0;
//		i = 0;

		break;

	case 2:
		read_pass(1500.0, 750.0, 2500.0);//(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel)

//		l = 480;
//		motor_enable = 1;
//		wait(300); 			//励磁直後は少し待つ！
//		distance3(180, l, 2500, 150, l, 0);
//		while (i != 1) {
//			i++;
//			total_dist = 0;
//			interrupt_kabekire = 1;
////			kabe_cancel = 30;
//			slalom_L2(90, 4300, 30.5, 59.5, 480, 6 + 5.5, 6.0, 1);
//		}
//		distance3(180, l, 2500, l, 150, 0);
//		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
//		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
//		wait(300); 			//励磁直後は少し待つ！
//		motor_enable = 0;
//		i = 0;

		break;

	case 3:		//
		read_pass_b(1500.0, 800.0, 2500.0);//(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel)

//		l = 800;
//		motor_enable = 1;
//		wait(300); 			//励磁直後は少し待つ！
//		distance3(180, l, 2500, 150, l, 0);
//		total_dist = 0;
//		while (i != 10) {
//			i++;
//			total_dist = 0;
//			interrupt_kabekire = 1;
//			slalom_L2(88, 4300, 38, 50, l, 41, 40, 0);
////			distance3(180, 480, 2500, 480, 480, 0);
//		}
////		slalom_L2(90, 4300, 30.5, 59.5, 480, 7.5, 0);
//		distance3(180, l, 2500, l, 150, 0);
//		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
//		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
//		wait(300); 			//励磁直後は少し待つ！
//		motor_enable = 0;
//		i = 0;
//		while (1) {
//		}
//		motor_enable = 1;
//		wait(300); 			//励磁直後は少し待つ！
//		distance3(90, 480, 2000, 150, 480, 0);
//		total_dist = 0;
//		slalom_L2(90, 4300, 31, 59, 480, 6 + 5.5, 6, 0); //(角度、最高角速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
//		total_dist = 0;
//		distance3(90, 480, 2000, 480, 150, 0);
//		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
//		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
//		wait(300); 			//励磁直後は少し待つ！
//		motor_enable = 0;
//
//		while (1) {
//		}
//		while (i != 31) {
//			i++;
//			distance3(180, 480, 3400, 480, 480, 0);
//			slalom_R2(90, 5200, 30, 60, 480, 13 - 4, 13, 0);
//		}
//		distance3(180, 480, 2500, 480, 150, 0);
//		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
//		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
//		wait(300); 			//励磁直後は少し待つ！
//		motor_enable = 0;
//		i = 0;
		break;
	case 4: 			//スラローム行きのみ探索調整用
		adachihou_q(goal_x, goal_y, 0, 0);

		//		read_pass(1700.0, 750.0, 2800.0);//(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel)
//
//		adachihou_q2_slalom(goal_x, goal_y, 0, 0, 480, 2000, 4300, 30.5, 59.5,
//				30.5, 59.5, 6.0, 9.0, 6.0 + 5.5, 6.0); //スラローム調整用
//		LED2_y = 1;
//		WALL_INFORMATION_convert();
//		WATCHED_WALL_INFORMATION_convert();
//
//		Q_node_map_maker(0, 0);
//		node_map_display();
//
//
//		unknown_WALL_add();
//
//		q_walk_map_maker(goal_x, goal_y);		//更新して作り直した迷路状法をもとに歩数マップを作成
//		make_pass(goal_x, goal_y);		//行動の確認
//		convert_pass();		//ぱすを大廻化
//		LED2_y = 0;

////		MAP_INFORMATION_convert();	←これが災いのもと
//		WALL_INFORMATION_convert();
//		WATCHED_WALL_INFORMATION_convert();
//		while (1) {
//			if (PE.DRL.BIT.B11 == 0) {
//				break;
//			}
//		}
//		walkmap_display();
//		unknown_WALL_add();
//		q_walk_map_maker(goal_x, goal_y);		//更新して作り直した迷路状法をもとに歩数マップを作成
//
//		walkmap_display();
//		make_pass(goal_x, goal_y);		//行動の確認
//		LED2_y = 1;
//		while (1) {
//			if (PE.DRL.BIT.B11 == 0) {
//				break;
//			}
//		}
//		for (i = 0; i <= last_p_i; i++) {
//			myprintf("pass[%d]=%d\n\r", i, pass[i]);
//		}
////		myprintf("壁(11,3,3)=%d\n\r",is_Exist_Wall_2(11, 3, 3));
//		convert_pass();		//ぱすを大廻化
//		while (1) {
//			if (PE.DRL.BIT.B11 == 0) {
//				break;
//			}
//		}
//
//		for (i = 0; i <= last_p_i; i++) {
//			myprintf("con_pass[%d]%d\n\r", i, pass[i]);
//		}
//		LED2_y = 0;
//		while (1) {
//			if (PE.DRL.BIT.B11 == 0) {
//				break;
//			}
//		}
//		read_pass(1500.0, 750.0, 2500.0);//(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel)

		break;
	case 5:
		read_pass_b(2000.0, 800.0, 2900.0);//(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel)

		break;

//		motor_enable = 1;
//		wait(300); 			//励磁直後は少し待つ！
//		distance3(180, 480, 2000, 150, 480, 0);
//		total_dist = 0;
//		slalom_L2(90, 4800, 30, 60, 480, 10 + 5.5, 10, 0); //(角度、最高角速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
//		while (i != 31) {
//			i++;
//			distance3(180, 480, 3400, 480, 480, 0);
//			total_dist = 0;
//			slalom_L2(90, 4800, 30, 60, 480, 10 + 5.5, 10, 0);
//		}
//		distance3(180, 480, 2500, 480, 150, 0);
//		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
//		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
//		wait(300); 			//励磁直後は少し待つ！
//		motor_enable = 0;
//		i = 0;
//
//		break;
	case 6:
		adachihou_q2_kichikukan(goal_x, goal_y, 0, 0, 480, 2000, 4300, 30.5, 59.5,
				30.5, 59.5, 6.0, 9.0, 6.0 + 5.5, 6.0); //スラローム調整用
//		MAP_INFORMATION_convert();	←これが災いのもと
		WALL_INFORMATION_convert();
		WATCHED_WALL_INFORMATION_convert();
		wait(2000);
		motor_enable = 1;
		wait(300); 			//励磁直後は少し待つ！
		turn_clock3(180.0, 480, 2000.0, 150.0, 150.0);
		if (direction_count == 0) {		//方向反転！
			direction_count = 2;
		} else if (direction_count == 1) {
			direction_count = 3;
		} else if (direction_count == 2) {
			direction_count = 0;
		} else {
			direction_count = 1;
		}
//		direction_xy();		//スタート方向に初期値＋1する
		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		wait(300); 			//励磁直後は少し待つ！
		motor_enable = 0;
		adachihou_q2_kichikukan(0, 0, goal_x, goal_y, 480, 2000, 4300, 30.5, 59.5,
				30.5, 59.5, 6.0, 9.0, 6.0 + 5.5, 6.0); //スラローム調整用

		LED2_y = 1;
		WALL_INFORMATION_convert();
		WATCHED_WALL_INFORMATION_convert();
		unknown_WALL_add();

		q_walk_map_maker(goal_x, goal_y);		//更新して作り直した迷路状法をもとに歩数マップを作成
		make_pass(goal_x, goal_y);		//行動の確認
		convert_pass();		//ぱすを大廻化
		LED2_y = 0;
		//AD変換
//		sen_AD_display();

		break;
	case 7://		壁切れ直線試験
		motor_enable = 1;
		wait(300); 			//励磁直後は少し待つ！
		distance3(90, 500, 2700, 150, 500, 1);
		distance4(90 * 4, 500, 2500, 500, 500, 1);
//		for (i = 0; i < 3; i++) {
//			interrupt_kabekire = 2;
//			distance4(180, 500, 2500, 500, 500, 1);
//		}
		distance3(90, 500, 2500, 500, 150, 1);
		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		wait(500);
		motor_enable = 0;
		while (1) {
			if (PE.DRL.BIT.B11 == 0) {
				break;
			}
		}
		myprintf("d_i=%d\n\r", d_i);

		break;
	case 8:		//ノードマップの調整
		Q_node_map_maker(0, 0);
		node_map_display();
		break;
	case 9:
		break;
	case 10:
		//足立法往復（平常運転）！&　中間パラメータでのパス、ゴール ※本番で使用しました‼
		adachihou_q2_slalom(goal_x, goal_y, 0, 0, 480, 2000, 4300, 30.5, 59.5,
				30.5, 59.5, 9.0 - 4, 9.0, 6.0 + 5.5, 6.0); //スラローム調整用
		if (accident_flag == 0) {
			WALL_INFORMATION_convert();		//成功したら壁情報を保存
			WATCHED_WALL_INFORMATION_convert();
			MAP_INFORMATION_convert();		//成功したら迷路情報を保存
		} else {
			break;	//switch文を抜ける
		}

		//  wait(500);			//ゴールでの方向転換。180ターンだが…
		motor_enable = 1;
		wait(300); 			//励磁直後は少し待つ！
		turn_clock3(180.0, 480, 2000.0, 150.0, 150.0);
		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		wait(300); 			//励磁直後は少し待つ！
		motor_enable = 0;
		if (direction_count == 0) {		//方向反転！
			direction_count = 2;
		} else if (direction_count == 1) {
			direction_count = 3;
		} else if (direction_count == 2) {
			direction_count = 0;
		} else {
			direction_count = 1;
		}
//		direction_xy();		//スタート方向に初期値＋1する

		adachihou_q2_slalom(0, 0, x, y, 480, 2000, 4300, 30, 60, 31, 59,
				7.5 - 4, 7.5, 6.5 + 5.5, 6.5); //スラローム調整用
//		adachihou_q2(0, 0, x, y, 480, 2000);	//いざ、スタート地点へ
		if (accident_flag == 0) {
			WALL_INFORMATION_convert();		//成功したら壁情報を保存
			WATCHED_WALL_INFORMATION_convert();
			MAP_INFORMATION_convert();		//成功したら迷路情報を保存
		} else {
			break;	//switch文を抜ける
		}

		wait(1000);			//スタートでの方向転換
		motor_enable = 1;
		wait(300); 			//励磁直後は少し待つ！
		turn_clock3(180.0, 480, 2000.0, 150.0, 150.0);
		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		wait(300); 			//励磁直後は少し待つ！
		motor_enable = 0;
		if (direction_count == 0) {		//方向反転！
			direction_count = 2;
		} else if (direction_count == 1) {
			direction_count = 3;
		} else if (direction_count == 2) {
			direction_count = 0;
		} else {
			direction_count = 1;
		}
		direction_xy();		//スタート方向に初期値＋1する

		wait(1000);
		unknown_WALL_add();
		q_walk_map_maker(goal_x, goal_y);  //再びゴール座標を打ちこんで変換
		LED3_r = 1;
		adachihou_straight_map(goal_x, goal_y);		//パス経路設計
		LED3_r = 0;

		adachihou_straight(goal_x, goal_y, 2000, 480, 2500, 2000, 75);	//低パラメータ
		unknown_WALL_remove();		//パス用の経路から未探索壁を取り除く→次の探索へ
		WALL_INFORMATION_1_to_2();
		if (accident_flag == 0) {
		} else {	//switch文を抜ける
			break;
		}
		motor_enable = 1;
		wait(300); 			//励磁直後は少し待つ！
		turn_clock3(180.0, 480, 2000.0, 150.0, 150.0);
		if (direction_count == 0) {		//方向反転！
			direction_count = 2;
		} else if (direction_count == 1) {
			direction_count = 3;
		} else if (direction_count == 2) {
			direction_count = 0;
		} else {
			direction_count = 1;
		}
		direction_xy();		//スタート方向に初期値＋1する
		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		wait(300); 			//励磁直後は少し待つ！
		motor_enable = 0;

		wait(300);
		adachihou_q2(0, 0, x, y, 480, 2000);	//いざ、スタート地点へ
		if (accident_flag == 0) {
			WALL_INFORMATION_convert();		//成功したら壁情報を保存
			WATCHED_WALL_INFORMATION_convert();
			MAP_INFORMATION_convert();		//成功したら迷路情報を保存
		} else {
			break;
		}

		break;
	case 11:
		/*		//足立法往復のみ（平常運転）
		 adachihou_q2(goal_x, goal_y, 0, 1, 480, 2000);
		 if (accident_flag == 0) {
		 WALL_INFORMATION_convert();		//成功したら壁情報を保存
		 WATCHED_WALL_INFORMATION_convert();
		 MAP_INFORMATION_convert();		//成功したら迷路情報を保存
		 } else {
		 break;	//switch文を抜ける
		 }

		 //  wait(500);			//ゴールでの方向転換。180ターンだが…
		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 turn_clock3(180.0, 480, 2000.0, 150.0, 150.0);
		 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		 wait(300); 			//励磁直後は少し待つ！
		 motor_enable = 0;
		 if (direction_count == 0) {		//方向反転！
		 direction_count = 2;
		 } else if (direction_count == 1) {
		 direction_count = 3;
		 } else if (direction_count == 2) {
		 direction_count = 0;
		 } else {
		 direction_count = 1;
		 }
		 direction_xy();		//スタート方向に初期値＋1する

		 adachihou_q2(0, 0, x, y, 480, 2000);	//いざ、スタート地点へ
		 if (accident_flag == 0) {
		 WALL_INFORMATION_convert();		//成功したら壁情報を保存
		 WATCHED_WALL_INFORMATION_convert();
		 MAP_INFORMATION_convert();		//成功したら迷路情報を保存
		 } else {
		 break;	//switch文を抜ける
		 }

		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 turn_clock3(180.0, 480, 2000.0, 150.0, 150.0);
		 if (direction_count == 0) {		//方向反転！
		 direction_count = 2;
		 } else if (direction_count == 1) {
		 direction_count = 3;
		 } else if (direction_count == 2) {
		 direction_count = 0;
		 } else {
		 direction_count = 1;
		 }
		 direction_xy();		//スタート方向に初期値＋1する
		 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		 wait(300); 			//励磁直後は少し待つ！
		 motor_enable = 0;

		 adachihou_q2(0, 0, x, y, 480, 2000);	//いざ、スタート地点へ
		 if (accident_flag == 0) {
		 WALL_INFORMATION_convert();		//成功したら壁情報を保存
		 WATCHED_WALL_INFORMATION_convert();
		 MAP_INFORMATION_convert();		//成功したら迷路情報を保存
		 } else {
		 break;
		 }*/
//		//純粋な往復足立法
//		motor_enable = 1;
//		wait(300); 			//励磁直後は少し待つ！
//		PE.DRL.BIT.B0 = 0;	//B0=0で正回転
//		PE.DRL.BIT.B4 = 1;	//B4=1で正回転
//		adachihou_q(goal_x, goal_y, 0, 1);
//
//		wait(2000);
//		motor_enable = 1;
//		wait(300); 			//励磁直後は少し待つ！
//		turn_clock3(180.0, 400.0, 2000.0, 150.0, 150.0);
//		if (direction_count == 0) {		//方向反転！
//			direction_count = 2;
//		} else if (direction_count == 1) {
//			direction_count = 3;
//		} else if (direction_count == 2) {
//			direction_count = 0;
//		} else {
//			direction_count = 1;
//		}
//		direction_xy();		//スタート方向に初期値＋1する
//		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
//		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
//		wait(700); 			//励磁直後は少し待つ！
//		PE.DRL.BIT.B0 = 0;	//B0=0で正回転
//		PE.DRL.BIT.B4 = 1;	//B4=1で正回転
//		adachihou_q(0, 0, x, y);
//		q_dual_map_maker(goal_x, goal_y);  //再びゴール座標を打ちこんで変換
		break;
	case 12:		//パス、最高パラメータ
		unknown_WALL_add();
		q_walk_map_maker(goal_x, goal_y);  //再びゴール座標を打ちこんで変換
		LED3_r = 1;
		adachihou_straight_map(goal_x, goal_y);		//パス経路設計
		LED3_r = 0;

		adachihou_straight(goal_x, goal_y, 2700, 480, 3000, 2500, 30);
//		unknown_WALL_remove();		//パス用の経路から未探索壁を取り除く→次の探索へ
		break;
	case 13:
//		while (i < 20) {	//超信地調整
//			i++;
//			motor_enable = 1;
//			wait(300); 			//励磁直後は少し待つ！
//			turn_clock3(180.0, 400.0, 2000.0, 150.0, 150.0);
//			MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
//			MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
//			wait(300);
//			motor_enable = 0;
//			wait(700);
//		}
		break;
	case 14:	//Battery　AD変換
		/*		while (1) {
		 init_sci();				//teratermの使い方確認
		 //		myprintf("kabocha\n");
		 initAD();
		 AD0.ADCR.BIT.ADST = 0;	//BatteryのAD変換
		 AD0.ADCSR.BIT.CH = 0;
		 AD0.ADCR.BIT.ADST = 1;
		 while (AD0.ADCSR.BIT.ADF == 0)
		 ;
		 AD0.ADCSR.BIT.ADF = 0;

		 SEN = AD0.ADDR0 >> 6;
		 Battery = 5.0 * 151.0 / 51.0 * SEN / 1024.0;
		 myprintf("電圧値=%f\n\r", Battery);
		 wait(100);
		 }
		 //帰りを含んだ足立法
		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
		 adachihou_q(goal_x, goal_y, 0, 1);
		 wait(2000);
		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 turn_clock3(180.0, 400.0, 2000.0, 150.0, 150.0);
		 if (direction_count == 0) {		//方向反転！
		 direction_count = 2;
		 } else if (direction_count == 1) {
		 direction_count = 3;
		 } else if (direction_count == 2) {
		 direction_count = 0;
		 } else {
		 direction_count = 1;
		 }
		 direction_xy();

		 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		 wait(700); 			//励磁直後は少し待つ！
		 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
		 direction_count = 0;
		 adachihou_q(0, 0, x, y);
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }*/
		/*		walkmap_display();
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }
		 footmark_display();
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }*/
		/*				q_dual_map_maker(goal_x, goal_y);  //再びゴール座標を打ちこんで変換
		 //		q_NOT_short_map_maker(4,0);
		 //		walkmap_display();
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }
		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
		 adachihou(goal_x, goal_y);
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }
		 walkmap_display();*/

		/*		//左手法
		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
		 hidaritehou3(4, 3);
		 q_walk_map_maker(goal_x, goal_y);
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }
		 walkmap_display();*/
//		footmark_display();
		/*		//ベクトルマップ法
		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
		 adachihou_q(goal_x, goal_y, 0, 1);
		 wait(2000);
		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 turn_clock3(180.0, 400.0, 2000.0, 150.0, 150.0); //回る角度はゴールした方向によりますが…
		 if (direction_count == 0) {		//方向反転！
		 direction_count = 2;
		 } else if (direction_count == 1) {
		 direction_count = 3;
		 } else if (direction_count == 2) {
		 direction_count = 0;
		 } else {
		 direction_count = 1;
		 }
		 direction_xy();
		 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		 wait(700); 			//励磁直後は少し待つ！
		 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
		 adachihou_q(0, 0, x, y);	//スタートをゴールに書き換える
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }
		 walkmap_display();
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }
		 footmark_display();
		 q_walk_map_maker(goal_x, goal_y);  //再びゴール座標を打ちこんで変換
		 walkmap_display();
		 while (1) {
		 if (PE.DRL.BIT.B10 == 0) {
		 break;
		 }
		 }
		 q_vector_map_maker(goal_x, goal_y);
		 walkmap_display();*/
//		vector_display();
		break;

	}
}
void distance4(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
		float vterm, int kabeseigyo) {
//	motor_enable = 1;
//	wait(300); 			//励磁直後は少し待つ！
	MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
	wall_control = kabeseigyo;
	speed = v_0;
	total_dist = 0.0;
	interrupt_kabekire = 2;
	if (hikisuu_dist
			<= ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					+ (vmax * vmax - vterm * vterm) / 2.0 / hikisuu_accel) {//三角加速
		while (1) {
			if (interrupt_kabekire >= 1/* && v_0 == vterm && vterm == vmax*/) {
				d_i = 0;
				if (kabe_cancel == 30) {		//左折の時は左のみ
					if (flag_kabekire == 1) { //壁切れ補正　Ⅰ壁あり→壁無し
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 42 + 90 * (d_i - 1);
//					total_dist = 132;
						LED3_r = 1;
						test1 = 800;
					} else if (flag_kabekire == 2) { //壁切れ補正　Ⅱ壁無し→壁あり
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 23 + 90 * (d_i - 1);
//					total_dist = 113; //
						LED2_y = 1;
						test1 = 800;
					}
				}
				if (kabe_cancel == 20) { //右折の時は右壁
					if (flag_kabekire == 10) {		//右　壁切れ補正　Ⅰ壁あり→壁無し
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 39 + 90 * (d_i - 1);		//132 - 5;
						LED3_r = 1;
						test1 = 800;
					} else if (flag_kabekire == 20) {		//右　壁切れ補正　Ⅱ壁無し→壁あり
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 18 + 90 * (d_i - 1);
//					total_dist = 113 - 5;		//あてずっぽうの値！
						LED2_y = 1;
						test1 = 800;
					}
				} else {
				}
				if (flag_kabekire == 1) { //壁切れ補正　Ⅰ壁あり→壁無し
					while (1) {
						if (total_dist - 90 * d_i >= 0) {
						} else if (total_dist - 90 * d_i < 0) {
							break;
						}
						d_i++;
					}
					total_dist = 42 +4 + 90 * (d_i - 1);
//					total_dist = 132;
					LED3_r = 1;
					test1 = 800;
				} else if (flag_kabekire == 2) { //壁切れ補正　Ⅱ壁無し→壁あり
					while (1) {
						if (total_dist - 90 * d_i >= 0) {
						} else if (total_dist - 90 * d_i < 0) {
							break;
						}
						d_i++;
					}
					total_dist = 23 + 90 * (d_i - 1);
//					total_dist = 113; //
					LED2_y = 1;
					test1 = 800;
				} else if (flag_kabekire == 10) {		//右　壁切れ補正　Ⅰ壁あり→壁無し
					while (1) {
						if (total_dist - 90 * d_i >= 0) {
						} else if (total_dist - 90 * d_i < 0) {
							break;
						}
						d_i++;
					}
					total_dist = 39 + 90 * (d_i - 1);		//132 - 5;
					LED3_r = 1;
					test1 = 800;
				} else if (flag_kabekire == 20) {		//右　壁切れ補正　Ⅱ壁無し→壁あり
					while (1) {
						if (total_dist - 90 * d_i >= 0) {
						} else if (total_dist - 90 * d_i < 0) {
							break;
						}
						d_i++;
					}
					total_dist = 21 + 90 * (d_i - 1);
//					total_dist = 113 - 5;		//あてずっぽうの値！
					LED2_y = 1;
					test1 = 800;
				} else {
				}
			}

			if (test1 == 1) { //インターフェイスLED
				LED3_r = 0;
				test1 = 0;
				LED2_y = 0;
			} else if (test1 > 0) {
				test1--;
			}

			if (total_dist
					<= hikisuu_dist / 2
							+ (vterm * vterm - v_0 * v_0) / 4 / hikisuu_accel) {
				accel = hikisuu_accel;
			} else if (total_dist
					> hikisuu_dist / 2
							+ (vterm * vterm - v_0 * v_0) / 4 / hikisuu_accel
					&& total_dist < hikisuu_dist) {
				accel = -hikisuu_accel;
			} else if (total_dist >= hikisuu_dist) {
				accel = 0.0;
				/*				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				 wait(500);
				 motor_enable = 0;*/
				break;
			}
		}
	} else if (hikisuu_dist
			> ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					+ (vmax * vmax - vterm * vterm) / 2.0 / hikisuu_accel) { //台形加速
		while (1) {
			if (interrupt_kabekire >= 1/* && v_0 == vterm && vterm == vmax*/) {
				d_i = 0;
				if (kabe_cancel == 30) {		//左折の時は左のみ
					if (flag_kabekire == 1) { //壁切れ補正　Ⅰ壁あり→壁無し
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 42 +1 + 90 * (d_i - 1);
//					total_dist = 132;
						LED3_r = 1;
						test1 = 800;
					} else if (flag_kabekire == 2) { //壁切れ補正　Ⅱ壁無し→壁あり
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 23 + 90 * (d_i - 1);
//					total_dist = 113; //
						LED2_y = 1;
						test1 = 800;
					}
				}else if (kabe_cancel == 20) { //右折の時は右壁
					if (flag_kabekire == 10) {		//右　壁切れ補正　Ⅰ壁あり→壁無し
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 39 + 90 * (d_i - 1);		//132 - 5;
						LED3_r = 1;
						test1 = 800;
					} else if (flag_kabekire == 20) {		//右　壁切れ補正　Ⅱ壁無し→壁あり
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 21 + 90 * (d_i - 1);
//					total_dist = 113 - 5;		//あてずっぽうの値！
						LED2_y = 1;
						test1 = 800;
					}
				} else {
					if (flag_kabekire == 1) { //壁切れ補正　Ⅰ壁あり→壁無し
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 42 +11 - 10 + 90 * (d_i - 1);
//					total_dist = 132;
						LED3_r = 1;
						test1 = 800;
					} else if (flag_kabekire == 2) { //壁切れ補正　Ⅱ壁無し→壁あり
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 23 + 90 * (d_i - 1);
//					total_dist = 113; //
						LED2_y = 1;
						test1 = 800;
					} else if (flag_kabekire == 10) {		//右　壁切れ補正　Ⅰ壁あり→壁無し
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 39 + 90 * (d_i - 1);		//132 - 5;
						LED3_r = 1;
						test1 = 800;
					} else if (flag_kabekire == 20) {		//右　壁切れ補正　Ⅱ壁無し→壁あり
						while (1) {
							if (total_dist - 90 * d_i >= 0) {
							} else if (total_dist - 90 * d_i < 0) {
								break;
							}
							d_i++;
						}
						total_dist = 21 + 90 * (d_i - 1);
//					total_dist = 113 - 5;		//あてずっぽうの値！
						LED2_y = 1;
						test1 = 800;
					} else {
					}
				}
			}

			if (test1 == 1) { //インターフェイスLED
				LED3_r = 0;
				test1 = 0;
				LED2_y = 0;
			} else if (test1 > 0) {
				test1--;
			}

			if (total_dist
					< ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)) {
				accel = hikisuu_accel;
			} else if (total_dist
					>= ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					&& total_dist
							<= (hikisuu_dist
									- (vmax * vmax - vterm * vterm) / 2.0
											/ hikisuu_accel)) {
				accel = 0;
			} else if (total_dist
					> (hikisuu_dist
							- (vmax * vmax - vterm * vterm) / 2.0
									/ hikisuu_accel)
					&& total_dist < hikisuu_dist) {
				accel = -1 * hikisuu_accel;
			} else if (total_dist >= hikisuu_dist) {
				accel = 0.0;
				break;
			}
		}
	}
	kabe_cancel = 0;
	interrupt_kabekire = 0;
}

void distance3(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
		float vterm, int kabeseigyo) {
//	motor_enable = 1;
//	wait(300); 			//励磁直後は少し待つ！
	MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
	wall_control = kabeseigyo;
	speed = v_0;
	total_dist = 0.0;
//	interrupt_kabekire = 1;

	if (hikisuu_dist
			<= ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					+ (vmax * vmax - vterm * vterm) / 2.0 / hikisuu_accel) {//三角加速(←壁切れは不要だが一応入れている)
		while (1) {
			if (flag_kabekire == 1) {		//壁切れ補正　Ⅰ壁あり→壁無し
				if (interrupt_kabekire >= 1 && v_0 == vterm && vterm == vmax) {
					total_dist = 132;
					interrupt_kabekire = interrupt_kabekire - 1;
				}
			} else if (flag_kabekire == 2) {		//壁切れ補正　Ⅱ壁無し→壁あり
				if (interrupt_kabekire >= 1 && v_0 == vterm && vterm == vmax) {
					total_dist = 113;		//あてずっぽうの値！
//					interrupt_kabekire = interrupt_kabekire - 1;
				}
			}

			if (total_dist
					<= hikisuu_dist / 2
							+ (vterm * vterm - v_0 * v_0) / 4 / hikisuu_accel) {
				accel = hikisuu_accel;
			} else if (total_dist
					> hikisuu_dist / 2
							+ (vterm * vterm - v_0 * v_0) / 4 / hikisuu_accel
					&& total_dist < hikisuu_dist) {
				accel = -hikisuu_accel;
			} else if (total_dist >= hikisuu_dist) {
				accel = 0.0;
				/*				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				 wait(500);
				 motor_enable = 0;*/
				break;
			}
		}
	} else if (hikisuu_dist
			> ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					+ (vmax * vmax - vterm * vterm) / 2.0 / hikisuu_accel) { //台形加速
		while (1) {
			if (flag_kabekire == 1) { //壁切れ補正　Ⅰ壁あり→壁無し
				if (interrupt_kabekire >= 1 && v_0 == vterm && vterm == vmax) {
					total_dist = 132;
					LED3_r = 1;
					test1 = 800; //待ち時間確保
//					interrupt_kabekire = interrupt_kabekire - 1;
				} else if (interrupt_kabekire >= 1 && vterm == vmax
						&& hikisuu_dist == 90) { //袋小路からの半区間のため
					total_dist = 132 - 90;
					LED3_r = 1;
					test1 = 800; //待ち時間確保
				}
			} else if (flag_kabekire == 2) { //壁切れ補正　Ⅱ壁無し→壁あり
				if (interrupt_kabekire >= 1 && v_0 == vterm && vterm == vmax) {
					total_dist = 113; //
					LED2_y = 1;
					test1 = 800;
//					interrupt_kabekire = interrupt_kabekire - 1;
				} else if (interrupt_kabekire >= 1 && vterm == vmax
						&& hikisuu_dist == 90) { //袋小路からの半区間のため
					total_dist = 113 - 90; //
					LED2_y = 1;
					test1 = 800;
				}
			} else {
			}
			if (test1 == 1) {
				LED3_r = 0;
				test1 = 0;
				LED2_y = 0;
			} else if (test1 > 0) {
				test1--;
			}

			if (total_dist
					< ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)) {
				accel = hikisuu_accel;
			} else if (total_dist
					>= ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					&& total_dist
							<= (hikisuu_dist
									- (vmax * vmax - vterm * vterm) / 2.0
											/ hikisuu_accel)) {
				accel = 0;
			} else if (total_dist
					> (hikisuu_dist
							- (vmax * vmax - vterm * vterm) / 2.0
									/ hikisuu_accel)
					&& total_dist < hikisuu_dist) {
				accel = -1 * hikisuu_accel;
			} else if (total_dist >= hikisuu_dist) {
				accel = 0.0;
				/*				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				 wait(500);
				 motor_enable = 0;*/
				break;
			}
		}
	}
	interrupt_kabekire = 0;
}

void slalom_R(float hikisuu_angle, float omega_max, float hikisuu_angacc,
		float v_turn, float omega_term, float offset, int kabeseigyo) {
	PE.DRL.BIT.B0 = 0;	//B0=0で正回転
	PE.DRL.BIT.B4 = 1;	//B4=1で正回転
	MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
	wall_control = kabeseigyo;
	hikisuu_angle = hikisuu_angle * pi / 180.0;		//度からラジアンへの変換
	omega_max = omega_max * pi / 180.0;
	hikisuu_angacc = hikisuu_angacc * pi / 180.0;
	omega_term = omega_term * pi / 180.0;

	speed = v_turn;
	angle = 0.0;
	omega = 0.0;
	total_dist = 0.0;
	distance3(offset, v_turn, 2000, v_turn, v_turn, 0);
	if (hikisuu_angle
			<= ((omega_max * omega_max) / (2.0 * hikisuu_angacc))
					+ (omega_max * omega_max - omega_term * omega_term)
							/ (2.0 * hikisuu_angacc)) {		//三角加速
//		myprintf("角度=%f\n\r",	2 * (omega_max * omega_max ) / (2.0 * hikisuu_angacc));
//		myprintf("hikisuu_angacc=%f\n\r",hikisuu_angacc);
//		myprintf("omega_max=%f\n\r",omega_max);
		while (1) {
			if (angle
					<= hikisuu_angle / 2.0
							+ (omega_term * omega_term) / 4.0
									/ hikisuu_angacc) {
				angacc = hikisuu_angacc;
				LED2_y = 1;
				LED1_p = 0;
			} else if (angle
					> hikisuu_angle / 2.0
							+ (omega_term * omega_term) / 4.0 / hikisuu_angacc
					&& angle < hikisuu_angle) {
				angacc = -1.0 * hikisuu_angacc;
				LED2_y = 0;
				LED1_p = 1;
				if (omega < 0) {
					angle = hikisuu_angle;
				}

//				if(omega<0){
//					myprintf("angle=%f\n\r",angle);
//					myprintf("omega=%f\n\r",omega);
//
//					while(1){
//					}
//				}
			} else if (angle >= hikisuu_angle) {
				angacc = 0.0;
				omega = 0.0;
//				myprintf("angle=%f\n\r",angle);
				break;
			}
		}
	} else if (hikisuu_angle
			> ((omega_max * omega_max) / 2.0 / hikisuu_angacc)
					+ (omega_max * omega_max - omega_term * omega_term) / 2.0
							/ hikisuu_angacc) { //台形加速
//				myprintf("hikisuu_angacc=%f\n\r",hikisuu_angacc);
//				myprintf("omega_max=%f\n\r",omega_max);
//		myprintf("角度=%f\n\r",	2 * (omega_max * omega_max ) / (2.0 * hikisuu_angacc));
		while (1) {
			if (angle < ((omega_max * omega_max) / 2.0 / hikisuu_angacc)) {
				angacc = hikisuu_angacc;
				LED3_r = 1;

			} else if (angle >= ((omega_max * omega_max) / 2.0 / hikisuu_angacc)
					&& angle
							<= (hikisuu_angle
									- (omega_max * omega_max
											- omega_term * omega_term) / 2.0
											/ hikisuu_angacc)) {
				angacc = 0.0;

			} else if (angle
					> (hikisuu_angle
							- (omega_max * omega_max - omega_term * omega_term)
									/ 2.0 / hikisuu_angacc)
					&& angle < hikisuu_angle) {
				angacc = -1.0 * hikisuu_angacc;
				if (omega < 0) {
					angle = hikisuu_angle;
				}
//				if(omega<0){
//					myprintf("条件=%f\n\r",(hikisuu_angle
//							- (omega_max * omega_max - omega_term * omega_term)
//									/ 2.0 / hikisuu_angacc));
//					myprintf("hikisuu_angle=%f\n\r",hikisuu_angle);
//					myprintf("angle=%f\n\r",angle);
//					myprintf("omega=%f\n\r",omega);
//					while(1){
//					}
//				}
			} else if (angle >= hikisuu_angle) {
				angacc = 0.0;
				omega = 0.0;
//				myprintf("angle=%f\n\r",angle);
//				myprintf("speed_r=%f\n\r",speed_r);
				LED3_r = 0;
				break;
			}
		}
	}
	distance3(offset, v_turn, 2000, v_turn, v_turn, 0);
}
void slalom_L(float hikisuu_angle, float omega_max, float hikisuu_angacc,
		float v_turn, float omega_term, float offset, int kabeseigyo) {
	PE.DRL.BIT.B0 = 0;	//B0=0で正回転
	PE.DRL.BIT.B4 = 1;	//B4=1で正回転
	MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
	wall_control = kabeseigyo;
	hikisuu_angle = hikisuu_angle * pi / 180.0;		//度からラジアンへの変換
	omega_max = omega_max * pi / 180.0;
	hikisuu_angacc = hikisuu_angacc * pi / 180.0;
	omega_term = omega_term * pi / 180.0;

	speed = v_turn;
	angle = 0.0;
	omega = 0.0;
	total_dist = 0.0;

	distance3(offset, v_turn, 2000, v_turn, v_turn, 0);
	if (hikisuu_angle
			<= ((omega_max * omega_max) / (2.0 * hikisuu_angacc))
					+ (omega_max * omega_max - omega_term * omega_term)
							/ (2.0 * hikisuu_angacc)) {		//三角加速
		while (1) {
			if (-1.0 * angle
					<= hikisuu_angle / 2.0
							+ (omega_term * omega_term) / 4.0
									/ hikisuu_angacc) {
				angacc = -1.0 * hikisuu_angacc;
				LED2_y = 1;
				LED1_p = 0;
			} else if (-1.0 * angle
					> hikisuu_angle / 2.0
							+ (omega_term * omega_term) / 4.0 / hikisuu_angacc
					&& -1.0 * angle < hikisuu_angle) {
				angacc = hikisuu_angacc;
				LED2_y = 0;
				LED1_p = 1;
//				if(omega<0){
//				-1.0*angle=hikisuu_angle
//				}
			} else if (-1.0 * angle >= hikisuu_angle) {
				angacc = 0.0;
				omega = 0.0;
				break;
			}
		}
	} else if (hikisuu_angle
			> ((omega_max * omega_max) / 2.0 / hikisuu_angacc)
					+ (omega_max * omega_max - omega_term * omega_term) / 2.0
							/ hikisuu_angacc) { //台形加速
		while (1) {
			if (-1.0 * angle
					< ((omega_max * omega_max) / 2.0 / hikisuu_angacc)) {
				angacc = -1.0 * hikisuu_angacc;
				LED3_r = 1;

			} else if (-1.0 * angle
					>= ((omega_max * omega_max) / 2.0 / hikisuu_angacc)
					&& -1.0 * angle
							<= (hikisuu_angle
									- (omega_max * omega_max
											- omega_term * omega_term) / 2.0
											/ hikisuu_angacc)) {
				angacc = 0.0;

			} else if (-1.0 * angle
					> (hikisuu_angle
							- (omega_max * omega_max - omega_term * omega_term)
									/ 2.0 / hikisuu_angacc)
					&& -1.0 * angle < hikisuu_angle) {
				angacc = hikisuu_angacc;
//				if(omega<0){
//				-1.0*angle = hikisuu_angle
//				}
			} else if (-1.0 * angle >= hikisuu_angle) {
				angacc = 0.0;
				omega = 0.0;
				LED3_r = 0;
				break;
			}
		}
	}
	distance3(offset, v_turn, 2000, v_turn, v_turn, 0);
}
void slalom_R2(float hikisuu_angle, float hikisuu_angacc, float angle1,
		float angle2, float v_turn, float offset1, float offset2,
		int kabeseigyo) {
	PE.DRL.BIT.B0 = 0;	//B0=0で正回転
	PE.DRL.BIT.B4 = 1;	//B4=1で正回転
	MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
	wall_control = kabeseigyo;
	hikisuu_angle = hikisuu_angle * pi / 180.0;		//度からラジアンへの変換
	hikisuu_angacc = hikisuu_angacc * pi / 180.0;
	angle1 = angle1 * pi / 180.0;
	angle2 = angle2 * pi / 180.0;

	speed = v_turn;
	angle = 0.0;
	omega = 0.0;
//	total_dist = 0.0;
	distance4(offset1, v_turn, 2000, v_turn, v_turn, kabeseigyo);
	wall_control = 0;
	while (1) {
		if (angle < angle1) {
			angacc = hikisuu_angacc;
//			LED3_r = 1;

		} else if (angle >= angle1 && angle <= angle2) {
			angacc = 0.0;

		} else if (angle > angle2 && angle < hikisuu_angle) {
			angacc = -1.0 * hikisuu_angacc;
			if (omega < 0) {
				angle = hikisuu_angle;
			}
		} else if (angle >= hikisuu_angle) {
			angacc = 0.0;
			omega = 0.0;
//			LED3_r = 0;
			break;
		}
	}
	distance3(offset2, v_turn, 2000, v_turn, v_turn, kabeseigyo);
}
void slalom_L2(float hikisuu_angle, float hikisuu_angacc, float angle1,
		float angle2, float v_turn, float offset1, float offset2,
		int kabeseigyo) {
	PE.DRL.BIT.B0 = 0;	//B0=0で正回転
	PE.DRL.BIT.B4 = 1;	//B4=1で正回転
	MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
	wall_control = kabeseigyo;
	hikisuu_angle = hikisuu_angle * pi / 180.0;		//度からラジアンへの変換
	hikisuu_angacc = hikisuu_angacc * pi / 180.0;
	angle1 = angle1 * pi / 180.0;
	angle2 = angle2 * pi / 180.0;

	speed = v_turn;
	angle = 0.0;
	omega = 0.0;
//	total_dist = 0.0;
	distance4(offset1, v_turn, 2000, v_turn, v_turn, kabeseigyo);
	wall_control = 0;
	while (1) {
		if (angle > -1.0 * angle1) {
			angacc = -1.0 * hikisuu_angacc;
//			LED3_r = 1;

		} else if (angle <= -1.0 * angle1 && angle >= -1.0 * angle2) {
			angacc = 0.0;

		} else if (angle < -1.0 * angle2 && angle > -1.0 * hikisuu_angle) {
			angacc = hikisuu_angacc;
			if (omega > 0) {
				angle = -1.0 * hikisuu_angle;
			}
		} else if (angle <= -1.0 * hikisuu_angle) {
			angacc = 0.0;
			omega = 0.0;
//			LED3_r = 0;
			break;
		}
	}
	distance3(offset2, v_turn, 2000, v_turn, v_turn, kabeseigyo);
}
void distance_q(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
		float vterm, int kabeseigyo) { //キューを呼び出しても距離がずれないようにするためにx座標の情報を抜いてある
//	motor_enable = 1;
//	wait(300); 			//励磁直後は少し待つ！
	MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
	wall_control = kabeseigyo;
	speed = v_0;
//	interrupt_kabekire = 1;
//	total_dist = 0.0;

	if (hikisuu_dist
			<= ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					+ (vmax * vmax - vterm * vterm) / 2.0 / hikisuu_accel) {//三角加速
		while (1) {
			if (flag_kabekire == 1) {		//壁切れ補正　Ⅰ壁あり→壁無し
				if (interrupt_kabekire >= 1 && v_0 == vterm && vterm == vmax) {
					total_dist = 132;
					interrupt_kabekire = 0;
				}
			} else if (flag_kabekire == 2) {		//壁切れ補正　Ⅱ壁無し→壁あり
				if (interrupt_kabekire >= 1 && v_0 == vterm && vterm == vmax) {
					total_dist = 113;		//あてずっぽうの値！
					interrupt_kabekire = 0;
				}
			}

			if (total_dist
					<= hikisuu_dist / 2
							+ (vterm * vterm - v_0 * v_0) / 4 / hikisuu_accel) {
				accel = hikisuu_accel;

//				LED2_y = 1;
			} else if (total_dist
					> hikisuu_dist / 2
							+ (vterm * vterm - v_0 * v_0) / 4 / hikisuu_accel
					&& total_dist < hikisuu_dist) {
				accel = -hikisuu_accel;
			} else if (total_dist >= hikisuu_dist) {
				accel = 0.0;
//				LED2_y = 0;
				break;
			}
		}
	} else if (hikisuu_dist
			> ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					+ (vmax * vmax - vterm * vterm) / 2.0 / hikisuu_accel) { //台形加速
		while (1) {
			if (interrupt_kabekire >= 1 && v_0 == vterm && vterm == vmax) { //以下は壁切れ

				if (flag_kabekire == 1) { //壁切れ補正　Ⅰ壁あり→壁無し
					total_dist = 132;
					LED3_r = 1;
					test1 = 800;
				} else if (flag_kabekire == 2) { //壁切れ補正　Ⅱ壁無し→壁あり
					total_dist = 113; //
					LED2_y = 1;
					test1 = 800;
				} else if (flag_kabekire == 10) {		//右　壁切れ補正　Ⅰ壁あり→壁無し
					total_dist = 132 - 5;
					LED3_r = 1;
					test1 = 800;
				} else if (flag_kabekire == 20) {		//右　壁切れ補正　Ⅱ壁無し→壁あり
					total_dist = 113 - 5;		//あてずっぽうの値！
					LED2_y = 1;
					test1 = 800;
				} else {
				}
			}

			if (test1 == 1) { //インターフェイスLED
				LED3_r = 0;
				test1 = 0;
				LED2_y = 0;
			} else if (test1 > 0) {
				test1--;
			}

			if (total_dist
					< ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)) {
				accel = hikisuu_accel;
			} else if (total_dist
					>= ((vmax * vmax - v_0 * v_0) / 2.0 / hikisuu_accel)
					&& total_dist
							<= (hikisuu_dist
									- (vmax * vmax - vterm * vterm) / 2.0
											/ hikisuu_accel)) {
				accel = 0;
			} else if (total_dist
					> (hikisuu_dist
							- (vmax * vmax - vterm * vterm) / 2.0
									/ hikisuu_accel)
					&& total_dist < hikisuu_dist) {
				accel = -1 * hikisuu_accel;
			} else if (total_dist >= hikisuu_dist) {
				accel = 0.0;
				break;
			}
		}
	}

}

void turn_clock3(float hikisuu_angle, float vmax2, float hikisuu_accel2,
		float v_0_2, float vterm2) { //超信地
	wall_control = 0;
	PE.DRL.BIT.B0 = 1;		//時計回りに回転
	PE.DRL.BIT.B4 = 1;
	distance3((pi * R_tread * hikisuu_angle / 180.0), vmax2, hikisuu_accel2,
			v_0_2, vterm2, 0);
}
void turn_unclock3(float hikisuu_angle, float vmax2, float hikisuu_accel2,
		float v_0_2, float vterm2) {	//超信地
	wall_control = 0;
	PE.DRL.BIT.B0 = 0;		//反時計回りに回転
	PE.DRL.BIT.B4 = 0;
	distance3((pi * R_tread * hikisuu_angle / 180.0), vmax2, hikisuu_accel2,
			v_0_2, vterm2, 0);
}
/*void hidaritehou2() {	//速度が連続的な左手法
 distance3(90.0, 600.0, 500.0, 150.0, 400.0, 1);
 while (1) {
 if (SEN_l_value < 150) {
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, 400.0, 1500.0, 400.0, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(300);
 turn_unclock3(90.0, 400.0, 1000.0, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(300);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 wall_control = 1;
 distance3(90.0, 400.0, 1500.0, 150.0, 400.0, 1);
 } else if (SEN_r_front_value < 130) {
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 //			wall_control = 1;
 distance3(180.0, 400.0, 1500.0, 400.0, 400.0, 1);
 } else if (SEN_r_value < 150) {
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, 400.0, 1500.0, 400.0, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(300);
 turn_clock3(90.0, 400.0, 1000.0, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(300);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 wall_control = 1;
 distance3(90.0, 400.0, 1500.0, 150.0, 400.0, 1);
 PB.DR.BIT.B2 = 1;
 LED2_y = 0;
 } else {
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, 400.0, 1500.0, 400.0, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(300);
 turn_clock3(180.0, 400.0, 1000.0, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(300);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, 400.0, 1500.0, 150.0, 400.0, 1);
 }
 }
 }*/
void direction_xy() {	//
	switch (direction_count) {
	case 0:		//North
		y++;
		break;
	case 1:		//East
		x++;
		break;
	case 2:		//South
		y--;
		break;
	case 3:		//West
		x--;
		break;
	}
}

void add_wall_front(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_y == 15) {
			break;
		}
		row[hikisuu_y] |= 32768 >> hikisuu_x;
		break;
	case 1:		//East
		if (hikisuu_x == 15) {
			break;
		}
		colum[hikisuu_x] |= 1 << hikisuu_y;
		break;
	case 2:		//South
		if (hikisuu_y == 0) {
			break;
		}
		row[hikisuu_y - 1] |= 32768 >> hikisuu_x;
		break;
	case 3:		//West
		if (hikisuu_x == 0) {
			break;
		}
		colum[hikisuu_x - 1] |= 1 << hikisuu_y;
		break;
	}
}
void add_wall_right(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_x == 15) {
			break;
		}
		colum[hikisuu_x] |= 1 << hikisuu_y;
		break;
	case 1:		//East
		if (hikisuu_y == 0) {
			break;
		}
		row[hikisuu_y - 1] |= 32768 >> hikisuu_x;
		break;
	case 2:		//South
		if (hikisuu_x == 0) {
			break;
		}
		colum[hikisuu_x - 1] |= 1 << hikisuu_y;
		break;
	case 3:		//West
		if (hikisuu_y == 15) {
			break;
		}
		row[hikisuu_y] |= 32768 >> hikisuu_x;
		break;
	}
}
void add_wall_left(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_x == 0) {
			break;
		}
		colum[hikisuu_x - 1] |= 0x0001 << hikisuu_y;
		break;
	case 1:		//East
		if (hikisuu_y == 15) {
			break;
		}
		row[hikisuu_y] |= 0x8000 >> hikisuu_x;
		break;
	case 2:		//South
		if (hikisuu_x == 15) {
			break;
		}
		colum[hikisuu_x] |= 0x0001 << hikisuu_y;
		break;
	case 3:		//West
		if (hikisuu_y == 0) {
			break;
		}
		row[hikisuu_y - 1] |= 0x8000 >> hikisuu_x;
		break;
	}
}
void add_wall_front_2(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_y == 15) {
			break;
		}
		row2[hikisuu_y] |= 32768 >> hikisuu_x;
		break;
	case 1:		//East
		if (hikisuu_x == 15) {
			break;
		}
		colum2[hikisuu_x] |= 1 << hikisuu_y;
		break;
	case 2:		//South
		if (hikisuu_y == 0) {
			break;
		}
		row2[hikisuu_y - 1] |= 32768 >> hikisuu_x;
		break;
	case 3:		//West
		if (hikisuu_x == 0) {
			break;
		}
		colum2[hikisuu_x - 1] |= 1 << hikisuu_y;
		break;
	}
}
void add_wall_right_2(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_x == 15) {
			break;
		}
		colum2[hikisuu_x] |= 1 << hikisuu_y;
		break;
	case 1:		//East
		if (hikisuu_y == 0) {
			break;
		}
		row2[hikisuu_y - 1] |= 32768 >> hikisuu_x;
		break;
	case 2:		//South
		if (hikisuu_x == 0) {
			break;
		}
		colum2[hikisuu_x - 1] |= 1 << hikisuu_y;
		break;
	case 3:		//West
		if (hikisuu_y == 15) {
			break;
		}
		row2[hikisuu_y] |= 32768 >> hikisuu_x;
		break;
	}
}
void add_wall_left_2(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_x == 0) {
			break;
		}
		colum2[hikisuu_x - 1] |= 0x0001 << hikisuu_y;
		break;
	case 1:		//East
		if (hikisuu_y == 15) {
			break;
		}
		row2[hikisuu_y] |= 0x8000 >> hikisuu_x;
		break;
	case 2:		//South
		if (hikisuu_x == 15) {
			break;
		}
		colum2[hikisuu_x] |= 0x0001 << hikisuu_y;
		break;
	case 3:		//West
		if (hikisuu_y == 0) {
			break;
		}
		row2[hikisuu_y - 1] |= 0x8000 >> hikisuu_x;
		break;
	}
}

void watched_wall_front_2(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_y == 15) {
			break;
		}
		row_watched2[hikisuu_y] |= 32768 >> hikisuu_x;
		break;
	case 1:		//East
		if (hikisuu_x == 15) {
			break;
		}
		colum_watched2[hikisuu_x] |= 1 << hikisuu_y;
		break;
	case 2:		//South
		if (hikisuu_y == 0) {
			break;
		}
		row_watched2[hikisuu_y - 1] |= 32768 >> hikisuu_x;
		break;
	case 3:		//West
		if (hikisuu_x == 0) {
			break;
		}
		colum_watched2[hikisuu_x - 1] |= 1 << hikisuu_y;
		break;
	}
}
void watched_wall_right_2(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_x == 15) {
			break;
		}
		colum_watched2[hikisuu_x] |= 1 << hikisuu_y;
		break;
	case 1:		//East
		if (hikisuu_y == 0) {
			break;
		}
		row_watched2[hikisuu_y - 1] |= 32768 >> hikisuu_x;
		break;
	case 2:		//South
		if (hikisuu_x == 0) {
			break;
		}
		colum_watched2[hikisuu_x - 1] |= 1 << hikisuu_y;
		break;
	case 3:		//West
		if (hikisuu_y == 15) {
			break;
		}
		row_watched2[hikisuu_y] |= 32768 >> hikisuu_x;
		break;
	}
}
void watched_wall_left_2(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:		//North
		if (hikisuu_x == 0) {
			break;
		}
		colum_watched2[hikisuu_x - 1] |= 0x0001 << hikisuu_y;
		break;
	case 1:		//East
		if (hikisuu_y == 15) {
			break;
		}
		row_watched2[hikisuu_y] |= 0x8000 >> hikisuu_x;
		break;
	case 2:		//South
		if (hikisuu_x == 15) {
			break;
		}
		colum_watched2[hikisuu_x] |= 0x0001 << hikisuu_y;
		break;
	case 3:		//West
		if (hikisuu_y == 0) {
			break;
		}
		row_watched2[hikisuu_y - 1] |= 0x8000 >> hikisuu_x;
		break;
	}
}

void setReached(char hikisuu_x, char hikisuu_y) {
	footmark[hikisuu_x][hikisuu_y] = 1;
}

int hasReached(char hikisuu_x, char hikisuu_y) {
	if (footmark[hikisuu_x][hikisuu_y] == 1) {
		Mark_Judge = 1;
	} else {
		Mark_Judge = 0;
	}
	return Mark_Judge;
}

int is_Exist_Wall(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:	//North
		Wall_Judge = row[hikisuu_y] & 0x8000 >> hikisuu_x;
		if (Wall_Judge == 0x8000 >> hikisuu_x) {
			Wall_Judge = 1;
		} else {
			Wall_Judge = 0;
		}
		return Wall_Judge;
		break;
	case 1:	//East
		Wall_Judge = colum[hikisuu_x] & 0x0001 << hikisuu_y;
		if (Wall_Judge == 0x0001 << hikisuu_y) {
			Wall_Judge = 1;
		} else {
			Wall_Judge = 0;
		}
		return Wall_Judge;
		break;
	case 2:	//South
		Wall_Judge = row[hikisuu_y - 1] & 0x8000 >> hikisuu_x;
		if (Wall_Judge == 0x8000 >> hikisuu_x) {
			Wall_Judge = 1;
		} else {
			Wall_Judge = 0;
		}
		return Wall_Judge;
		break;
	case 3:	//West
		Wall_Judge = colum[hikisuu_x - 1] & 0x0001 << hikisuu_y;
		if (Wall_Judge == 0x0001 << hikisuu_y) {
			Wall_Judge = 1;
		} else {
			Wall_Judge = 0;
		}
		return Wall_Judge;
		break;
	}
}
int is_Exist_Wall_2(int hikisuu_x, int hikisuu_y, int hikisuu_direction_count) {//走行中の、仮の壁情報を見ている
	switch (hikisuu_direction_count) {
	case 0:	//North
		Wall_Judge = row2[hikisuu_y] & 0x8000 >> hikisuu_x;
		if (Wall_Judge == 0x8000 >> hikisuu_x) {
			Wall_Judge = 1;
		} else {
			Wall_Judge = 0;
		}
		return Wall_Judge;
		break;
	case 1:	//East
		Wall_Judge = colum2[hikisuu_x] & 0x0001 << hikisuu_y;
		if (Wall_Judge == 0x0001 << hikisuu_y) {
			Wall_Judge = 1;
		} else {
			Wall_Judge = 0;
		}
		return Wall_Judge;
		break;
	case 2:	//South
		Wall_Judge = row2[hikisuu_y - 1] & 0x8000 >> hikisuu_x;
		if (Wall_Judge == 0x8000 >> hikisuu_x) {
			Wall_Judge = 1;
		} else {
			Wall_Judge = 0;
		}
		return Wall_Judge;
		break;
	case 3:	//West
		Wall_Judge = colum2[hikisuu_x - 1] & 0x0001 << hikisuu_y;
		if (Wall_Judge == 0x0001 << hikisuu_y) {
			Wall_Judge = 1;
		} else {
			Wall_Judge = 0;
		}
		return Wall_Judge;
		break;
	}
}
int is_the_Wall_watched(int hikisuu_x, int hikisuu_y,
		int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:	//North
		watched_Wall_Judge = row_watched[hikisuu_y] & 0x8000 >> hikisuu_x;
		if (watched_Wall_Judge == 0x8000 >> hikisuu_x) {
			watched_Wall_Judge = 1;
		} else {
			watched_Wall_Judge = 0;
		}
		return watched_Wall_Judge;
		break;
	case 1:	//East
		watched_Wall_Judge = colum_watched[hikisuu_x] & 0x0001 << hikisuu_y;
		if (watched_Wall_Judge == 0x0001 << hikisuu_y) {
			watched_Wall_Judge = 1;
		} else {
			watched_Wall_Judge = 0;
		}
		return watched_Wall_Judge;
		break;
	case 2:	//South
		watched_Wall_Judge = row_watched[hikisuu_y - 1] & 0x8000 >> hikisuu_x;
		if (watched_Wall_Judge == 0x8000 >> hikisuu_x) {
			watched_Wall_Judge = 1;
		} else {
			watched_Wall_Judge = 0;
		}
		return watched_Wall_Judge;
		break;
	case 3:	//West
		watched_Wall_Judge = colum_watched[hikisuu_x - 1] & 0x0001 << hikisuu_y;
		if (watched_Wall_Judge == 0x0001 << hikisuu_y) {
			watched_Wall_Judge = 1;
		} else {
			watched_Wall_Judge = 0;
		}
		return watched_Wall_Judge;
		break;
	}
}
int is_the_Wall_watched_2(int hikisuu_x, int hikisuu_y,	//走行中の、仮の壁の見たかどうかの情報を見ている
		int hikisuu_direction_count) {
	switch (hikisuu_direction_count) {
	case 0:	//North
		watched_Wall_Judge = row_watched2[hikisuu_y] & 0x8000 >> hikisuu_x;
		if (watched_Wall_Judge == 0x8000 >> hikisuu_x) {
			watched_Wall_Judge = 1;
		} else {
			watched_Wall_Judge = 0;
		}
		return watched_Wall_Judge;
		break;
	case 1:	//East
		watched_Wall_Judge = colum_watched2[hikisuu_x] & 0x0001 << hikisuu_y;
		if (watched_Wall_Judge == 0x0001 << hikisuu_y) {
			watched_Wall_Judge = 1;
		} else {
			watched_Wall_Judge = 0;
		}
		return watched_Wall_Judge;
		break;
	case 2:	//South
		watched_Wall_Judge = row_watched2[hikisuu_y - 1] & 0x8000 >> hikisuu_x;
		if (watched_Wall_Judge == 0x8000 >> hikisuu_x) {
			watched_Wall_Judge = 1;
		} else {
			watched_Wall_Judge = 0;
		}
		return watched_Wall_Judge;
		break;
	case 3:	//West
		watched_Wall_Judge = colum_watched2[hikisuu_x - 1]
				& 0x0001 << hikisuu_y;
		if (watched_Wall_Judge == 0x0001 << hikisuu_y) {
			watched_Wall_Judge = 1;
		} else {
			watched_Wall_Judge = 0;
		}
		return watched_Wall_Judge;
		break;
	}
}

/*void q_vector_map_maker(int hikisuu_goal_x, int hikisuu_goal_y) {//0地点がゴール座標に設定されている上でのお話！
 for (qx = 0; qx <= x_size; qx++)		// 未探索区間の初期化,255を代入
 {
 for (qy = 0; qy <= y_size; qy++) {
 if (hasReached(qx, qy) == 0) {
 map[qx][qy] = 255;

 }
 }
 }

 map[hikisuu_goal_x][hikisuu_goal_y] = 0;			// ゴール地点に距離０を書き込む
 q_v[0] = (1 * 4096 + 8 * 256 + hikisuu_goal_x * 16 + hikisuu_goal_y);// flag,ゴール地点の座標を記憶,8であるので東向きに出発するつもり
 head = 0;							// 先頭位置を初期化
 tail = 1;							// 末尾位置は、最後の情報位置＋１

 while (head != tail)				// 配列の中身が空ならループを抜ける（更新できないとループを抜ける）
 {
 qy = q_v[head] & 0x000f;       		// 配列から区画のy座標を取り出す
 qx = q_v[head] & 0x00ff >> 4;		//　配列から区画のx座標を取り出す
 direction_number = q_v[head] >> 8;		// 配列から区画の方向を取り出す（初期値は8で北）
 renewal_flag = q_v[head] >> 12;		//書き換えのフラグ
 head++;							// 情報を取り出したので先頭位置をずらす

 if (qy < y_size && map[qx][qy + 1] != 255)						// 北側をみる
 {
 if (map[qx][qy + 1] > map[qx][qy])	//北が探索済みの場合

 //			if (renewal_flag==0)				//まだ書き換えられていない場合
 {
 //				if (direction_number==8)	//さらに現在マップの前のマップが北方向の場合
 //						{
 //					map[qx][qy + 1] = map[qx][qy] + 1;		//次のマップは同じ方向より＋1
 //					q_s[tail] = (1*4096 + 8*256 + qx * 16 + qy + 1);     // 次の区画の座標、方向を記憶
 //					tail++;     // 情報を入れたので末尾位置をずらす
 //				}else{
 vector_map[qx][qy + 1] = 8;		//次のマップは別の方向だから＋2
 q_v[tail] = (1 * 4096 + 8 * 256 + qx * 16 + qy + 1); // 次の区画の座標、方向を記憶
 tail++;     // 情報を入れたので末尾位置をずらす

 //				}
 }
 }
 if (qx < x_size && map[qx + 1][qy] != 255)     // 東側
 {
 if (map[qx + 1][qy] > map[qx][qy])	//東が探索済みの場合

 //			if (renewal_flag==0)				//まだ書き換えられていない場合
 {
 //				if (direction_number==4)	//さらに現在マップの前のマップが東方向の場合
 //						{
 //					map[qx + 1][qy] = map[qx][qy] + 1;		//次のマップは同じ方向だから＋1
 //					q_s[tail] = (1*4096 + 4*256 + (qx + 1) * 16 + qy);     // 次の区画の座標を記憶
 //					tail++;     // 情報を入れたので末尾位置をずらす
 //				}else {
 vector_map[qx + 1][qy] = 4;		//次のマップは別の方向だから＋2
 q_v[tail] = (1 * 4096 + 4 * 256 + (qx + 1) * 16 + qy); // 次の区画の座標、方向を記憶
 tail++;     // 情報を入れたので末尾位置をずらす
 //
 //				}
 }
 }
 if (qy > 0 && map[qx][qy - 1] != 255)     // 南側
 {
 if (map[qx][qy - 1] > map[qx][qy])	//南に壁がない場合

 //			if (renewal_flag==0)				//まだ書き換えられていない場合
 {
 //				if (direction_number==2)	//さらにマップが過去に更新されていない場合
 //						{
 //					map[qx][qy - 1] = map[qx][qy] + 1;
 //					q_s[tail] = (1*4096 + 2*256 + qx * 16 + qy - 1);     // 次の区画の座標を記憶
 //					tail++;     // 情報を入れたので末尾位置をずらす
 //
 //				}else {
 vector_map[qx][qy - 1] = 2;
 q_v[tail] = (1 * 4096 + 2 * 256 + qx * 16 + qy - 1); // 次の区画の座標を記憶
 tail++;     // 情報を入れたので末尾位置をずらす

 //				}
 }
 }
 if (qx > 0 && map[qx - 1][qy] != 255)     // 西側
 {
 if (map[qx - 1][qy] > map[qx][qy])	//西に壁がない場合
 //			if (renewal_flag==0)				//まだ書き換えられていない場合
 {
 //				if (direction_number==1)	//さらにマップが過去に更新されていない場合
 //						{
 //					map[qx - 1][qy] = map[qx][qy] + 1;
 //					q_s[tail] = (1*4096 + 1*256 + (qx - 1) * 16 + qy);     // 次の区画の座標を記憶
 //					tail++;     // 情=報を入れたので末尾位置をずらす
 //
 //				}else {
 vector_map[qx - 1][qy] = 1;
 q_v[tail] = (1 * 4096 + 1 * 256 + (qx - 1) * 16 + qy); // 次の区画の座標を記憶
 tail++;     // 情=報を入れたので末尾位置をずらす

 //				}
 }
 }
 }

 }*/
void Q_node_map_maker(int hikisuu_start_x, int hikisuu_start_y) {//壁のノードに関する歩数マップを作成
	for (qx = 0; qx <= x_size; qx++)		// マップの初期化,500の代入
			{
		for (qy = 0; qy <= y_size; qy++) {
			node_center[qx][qy] = 500;
		}
	}
	node_center[hikisuu_start_x][hikisuu_start_y] = 0;// 目標地点(この場合はスタート地点かな？)に距離０を書き込む
	q[0] = (hikisuu_start_x * 16 + hikisuu_start_y);		// 目標地点の座標を記憶
	head = 0;							// 先頭位置を初期化
	tail = 1;							// 末尾位置は、最後の情報位置＋１

	while (head != tail)				// 配列の中身が空ならループを抜ける（更新できないとループを抜ける）
	{
		qy = q[head] & 0x0f;       		// 配列から区画の座標を取り出す
		qx = q[head] >> 4;
		head++;							// 情報を取り出したので先頭位置をずらす

		if (qy < y_size)							// 北側
		{
			if (is_Exist_Wall(qx, qy, 0) == 0)	//北に壁がない場合
					{
				if (node_center[qx][qy + 1] == 500)	//さらに中央ノードが過去に更新されていない場合
						{
					node_row[qx][qy + 1] = node_center[qx][qy] + 1;	//（qx,qy）座標の北のrowノードを+1する
					node_center[qx][qy + 1] = node_center[qx][qy] + 2;
					q[tail] = (qx * 16 + qy + 1);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす
				} else if (node_center[qx][qy + 1] == node_center[qx][qy] + 2) //中央ノードが現在地よりも大きい場合
						{
					node_row[qx][qy + 1] = node_center[qx][qy] + 1;	//（qx,qy）座標の北のrowノードを現在地に+1する
				} else if (node_center[qx][qy + 1] == node_center[qx][qy] - 2) //中央のノードが現在地よりも小さい場合
						{
					node_row[qx][qy + 1] = node_center[qx][qy] - 1;	//（qx,qy）座標の北のrowノードを現在地に-1する
				}
			}
		}
		if (qx < x_size)     // 東側
		{
			if (is_Exist_Wall(qx, qy, 1) == 0)	//東に壁がない場合
					{
				if (node_center[qx + 1][qy] == 500)	//さらに中央ノードが過去に更新されていない場合
						{
					node_colum[qx + 1][qy] = node_center[qx][qy] + 1;//（qx,qy）座標の東のcolumノードを+1する
					node_center[qx + 1][qy] = node_center[qx][qy] + 2;
					q[tail] = ((qx + 1) * 16 + qy);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす
				} else if (node_center[qx + 1][qy] == node_center[qx][qy] + 2) //中央ノードが現在地よりも大きい場合
						{
					node_colum[qx + 1][qy] = node_center[qx][qy] + 1; //（qx,qy）座標の東のcolumノードを現在地に+1する
				} else if (node_center[qx + 1][qy] == node_center[qx][qy] - 2) //中央のノードが現在地よりも小さい場合
						{
					node_colum[qx + 1][qy] = node_center[qx][qy] - 1; //（qx,qy）座標の東のcolumノードを現在地に-1する
				}
			}
		}
		if (qy > 0)     // 南側
				{
			if (is_Exist_Wall(qx, qy, 2) == 0)	//南に壁がない場合
					{
				if (node_center[qx][qy - 1] == 500)	//さらにマップが過去に更新されていない場合
						{
					node_row[qx][qy] = node_center[qx][qy] + 1;	//（qx,qy）座標の南のrowノードを+1する
					node_center[qx][qy - 1] = node_center[qx][qy] + 2;
					q[tail] = (qx * 16 + qy - 1);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす
				} else if (node_center[qx][qy - 1] == node_center[qx][qy] + 2) //中央ノードが現在地よりも大きい場合
						{
					node_row[qx][qy] = node_center[qx][qy] + 1;	//（qx,qy）座標の南のrowノードを現在地に+1する
				} else if (node_center[qx][qy - 1] == node_center[qx][qy] - 2) //中央のノードが現在地よりも小さい場合
						{
					node_row[qx][qy] = node_center[qx][qy] - 1;	//（qx,qy）座標の南のrowノードを現在地に-1する
				}
			}
		}
		if (qx > 0)     // 西側
				{
			if (is_Exist_Wall(qx, qy, 3) == 0)	//西に壁がない場合
					{
				if (node_center[qx - 1][qy] == 500)	//さらにマップが過去に更新されていない場合
						{
					node_colum[qx][qy] = node_center[qx][qy] + 1;//（qx,qy）座標の西のcolumノードを+1する
					node_center[qx - 1][qy] = node_center[qx][qy] + 2;
					q[tail] = ((qx - 1) * 16 + qy);     // 次の区画の座標を記憶
					tail++;     // 情=報を入れたので末尾位置をずらす
				} else if (node_center[qx - 1][qy] == node_center[qx][qy] + 2) //中央ノードが現在地よりも大きい場合
						{
					node_colum[qx][qy] = node_center[qx][qy] + 1; //（qx,qy）座標の西のcolumノードを現在地に+1する
				} else if (node_center[qx - 1][qy] == node_center[qx][qy] - 2) //中央のノードが現在地よりも小さい場合
						{
					node_colum[qx][qy] = node_center[qx][qy] - 1; //（qx,qy）座標の西のcolumノードを現在地に-1する
				}
			}
		}
	}
}

void q_walk_map_maker(int hikisuu_goal_x, int hikisuu_goal_y) {
	for (qx = 0; qx <= x_size; qx++)		// マップの初期化,255の代入
			{
		for (qy = 0; qy <= y_size; qy++) {
			map[qx][qy] = 255;
		}
	}
	map[hikisuu_goal_x][hikisuu_goal_y] = 0;			// 目標地点に距離０を書き込む
	q[0] = (hikisuu_goal_x * 16 + hikisuu_goal_y);		// 目標地点の座標を記憶
	head = 0;							// 先頭位置を初期化
	tail = 1;							// 末尾位置は、最後の情報位置＋１

	while (head != tail)				// 配列の中身が空ならループを抜ける（更新できないとループを抜ける）
	{
		qy = q[head] & 0x0f;       		// 配列から区画の座標を取り出す
		qx = q[head] >> 4;
		head++;							// 情報を取り出したので先頭位置をずらす

		if (qy < y_size)							// 北側
		{
			if (is_Exist_Wall(qx, qy, 0) == 0)	//北に壁がない場合
					{
				if (map[qx][qy + 1] == 255)	//さらにマップが過去に更新されていない場合
						{
					map[qx][qy + 1] = map[qx][qy] + 1;
					q[tail] = (qx * 16 + qy + 1);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qx < x_size)     // 東側
		{
			if (is_Exist_Wall(qx, qy, 1) == 0)	//東に壁がない場合
					{
				if (map[qx + 1][qy] == 255)	//さらにマップが過去に更新されていない場合
						{
					map[qx + 1][qy] = map[qx][qy] + 1;
					q[tail] = ((qx + 1) * 16 + qy);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qy > 0)     // 南側
				{
			if (is_Exist_Wall(qx, qy, 2) == 0)	//南に壁がない場合
					{
				if (map[qx][qy - 1] == 255)	//さらにマップが過去に更新されていない場合
						{
					map[qx][qy - 1] = map[qx][qy] + 1;
					q[tail] = (qx * 16 + qy - 1);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qx > 0)     // 西側
				{
			if (is_Exist_Wall(qx, qy, 3) == 0)	//西に壁がない場合
					{
				if (map[qx - 1][qy] == 255)	//さらにマップが過去に更新されていない場合
						{
					map[qx - 1][qy] = map[qx][qy] + 1;
					q[tail] = ((qx - 1) * 16 + qy);     // 次の区画の座標を記憶
					tail++;     // 情=報を入れたので末尾位置をずらす

				}
			}
		}
	}

}

void q_walk_map2_maker(int hikisuu_goal_x, int hikisuu_goal_y) { //足立法中に用い、仮の壁や歩数マップを読み取る
	for (qx = 0; qx <= x_size; qx++)		// マップの初期化,255の代入
			{
		for (qy = 0; qy <= y_size; qy++) {
			map2[qx][qy] = 255;
		}
	}
	map2[hikisuu_goal_x][hikisuu_goal_y] = 0;			// 目標地点に距離０を書き込む
	q[0] = (hikisuu_goal_x * 16 + hikisuu_goal_y);		// 目標地点の座標を記憶
	head = 0;							// 先頭位置を初期化
	tail = 1;							// 末尾位置は、最後の情報位置＋１

	while (head != tail)				// 配列の中身が空ならループを抜ける（更新できないとループを抜ける）
	{
		qy = q[head] & 0x0f;       		// 配列から区画の座標を取り出す
		qx = q[head] >> 4;
		head++;							// 情報を取り出したので先頭位置をずらす

		if (qy < y_size && ((row2[qy] & 0x8000 >> qx) == 0)
				&& map2[qx][qy + 1] == 255)			// 北側
						{
//			if (is_Exist_Wall_2(qx, qy, 0) == 0)	//北に壁がない場合
//					{
//				if (map2[qx][qy + 1] == 255)	//さらにマップが過去に更新されていない場合
//						{
			map2[qx][qy + 1] = map2[qx][qy] + 1;
			q[tail] = (qx * 16 + qy + 1);     // 次の区画の座標を記憶
			tail++;     // 情報を入れたので末尾位置をずらす
//
//				}
//			}
		}
		if (qx < x_size && ((colum2[qx] & 0x0001 << qy) == 0)
				&& map2[qx + 1][qy] == 255)     // 東側
						{
//			if (is_Exist_Wall_2(qx, qy, 1) == 0)	//東に壁がない場合
//					{
//				if (map2[qx + 1][qy] == 255)	//さらにマップが過去に更新されていない場合
//						{
			map2[qx + 1][qy] = map2[qx][qy] + 1;
			q[tail] = ((qx + 1) * 16 + qy);     // 次の区画の座標を記憶
			tail++;     // 情報を入れたので末尾位置をずらす
//
//				}
//			}
		}
		if (qy > 0 && ((row2[qy - 1] & 0x8000 >> qx) == 0)
				&& map2[qx][qy - 1] == 255)     // 南側
						{
//			if (is_Exist_Wall_2(qx, qy, 2) == 0)	//南に壁がない場合
//					{
//				if (map2[qx][qy - 1] == 255)	//さらにマップが過去に更新されていない場合
//						{
			map2[qx][qy - 1] = map2[qx][qy] + 1;
			q[tail] = (qx * 16 + qy - 1);     // 次の区画の座標を記憶
			tail++;     // 情報を入れたので末尾位置をずらす
//
//				}
//			}
		}
		if (qx > 0 && ((colum2[qx - 1] & 0x0001 << qy) == 0)
				&& map2[qx - 1][qy] == 255)     // 西側
						{
//			if (is_Exist_Wall_2(qx, qy, 3) == 0)	//西に壁がない場合
//					{
//				if (map2[qx - 1][qy] == 255)	//さらにマップが過去に更新されていない場合
//						{
			map2[qx - 1][qy] = map2[qx][qy] + 1;
			q[tail] = ((qx - 1) * 16 + qy);     // 次の区画の座標を記憶
			tail++;     // 情=報を入れたので末尾位置をずらす
//
//				}
//			}
		}
	}

}

void MAP_INFORMATION_convert() {		//迷路情報の保存・・・これ要る？
	for (qy = 0; qy <= y_size; qy++) {
		for (qx = 0; qx <= x_size; qx++) {
			map[qx][qy] = map2[qx][qy];
		}
	}
}
void WALL_INFORMATION_convert() {		//壁情報の保存、更新
	for (qx = 0; qx < x_size; qx++) {
		colum[qx] |= colum2[qx];
		row[qx] |= row2[qx];
	}
}
void WALL_INFORMATION_1_to_2() {		//がばがばだけど
	for (qx = 0; qx <= x_size; qx++) {
		colum2[qx] |= colum[qx];
		row2[qx] |= row[qx];
	}
}

void WATCHED_WALL_INFORMATION_convert() {		//壁を見たかどうかの情報の保存、更新
	for (qx = 0; qx <= x_size; qx++) {
		colum_watched[qx] |= colum_watched2[qx];
		row_watched[qx] |= row_watched2[qx];
	}
}

void unknown_WALL_add() {		//パス用に未探索壁を入れた
	for (qy = 0; qy <= y_size; qy++) {
		for (qx = 0; qx <= x_size; qx++) {
			if (is_the_Wall_watched(qx, qy, 0) == 0) {
				add_wall_front(qx, qy, 0);
			}
			if (is_the_Wall_watched(qx, qy, 1) == 0) {
				add_wall_right(qx, qy, 0);
			}
		}
	}
}
void unknown_WALL_remove() {		//パス用に入れた未探索壁を再び取り除いて探索へ！
//	watched_wall_front(0, 0, 0);		//読んでないけど初期条件で読ませておく
//	watched_wall_front(0, 0, 1);
	for (qy = 0; qy <= y_size; qy++) {
		for (qx = 0; qx <= x_size; qx++) {
			remove_row = 32768;
			remove_colum = 1;
//			l = ~32768 >> qx;
			if (is_the_Wall_watched(qx, qy, 0) == 0) {
				row[qy] = row[qy] & ~remove_row >> qx;

			}
			if (is_the_Wall_watched(qx, qy, 1) == 0) {
				remove_colum = remove_colum << qy;
				remove_colum = ~remove_colum;
				colum[qx] = colum[qx] & remove_colum;
			}
		}
	}
//		for (qx = 0; qx <= x_size; qx++) {
//			colum_watched[qx] = ~colum_watched[qx];
//			row_watched[qx] = ~row_watched[qx];
//			colum[qx] = colum[qx] & colum_watched[qx];
//			row[qx] = row[qx] & row_watched[qx];
//		}
}

void straight_map_clear() {
	for (qy = 0; qy <= y_size; qy++) {
		for (qx = 0; qx < x_size; qx++) {
			straight_map[qx][qy] = 0;
		}
	}
}

void q_dual_map_maker(int hikisuu_goal_x, int hikisuu_goal_y) {	//行っていない区間とUターンした区間を255にして、経路を算出している。パス用
	for (qx = 0; qx <= x_size; qx++)		// 未探索区間の初期化,255を代入
			{
		for (qy = 0; qy <= y_size; qy++) {
			if (hasReached(qx, qy) == 0 || hasReached(qx, qy) == 10) {//10はターンしたマス
				map[qx][qy] = 255;
			} else if (hasReached(qx, qy) == 1) {		//既知区間
				map[qx][qy] = 254;
			}
		}
	}

	map[hikisuu_goal_x][hikisuu_goal_y] = 0;			// 目標地点に距離０を書き込む
	q[0] = (hikisuu_goal_x * 16 + hikisuu_goal_y);		// 目標地点の座標を記憶
	head = 0;							// 先頭位置を初期化
	tail = 1;							// 末尾位置は、最後の情報位置＋１

	while (head != tail)				// 配列の中身が空ならループを抜ける（更新できないとループを抜ける）
	{
		qy = q[head] & 0x0f;       		// 配列から区画の座標を取り出す
		qx = q[head] >> 4;
		head++;							// 情報を取り出したので先頭位置をずらす

		if (qy < y_size && map[x][y + 1] != 255)			// 北側を見て未知区間にはいかない
				{
			if (is_Exist_Wall(qx, qy, 0) == 0)	//北に壁がない場合
					{
				if (map[qx][qy + 1] == 254)	//さらにマップが過去に更新されていない場合
						{
					map[qx][qy + 1] = map[qx][qy] + 1;
					q[tail] = (qx * 16 + qy + 1);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qx < x_size && map[x][y + 1] != 255)     // 東側を見て未知区間にはいかない
				{
			if (is_Exist_Wall(qx, qy, 1) == 0)	//東に壁がない場合
					{
				if (map[qx + 1][qy] == 254)	//さらにマップが過去に更新されていない場合
						{
					map[qx + 1][qy] = map[qx][qy] + 1;
					q[tail] = ((qx + 1) * 16 + qy);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qy > 0 && map[x][y + 1] != 255)     // 南側を見て未知区間にはいかない
				{
			if (is_Exist_Wall(qx, qy, 2) == 0)	//南に壁がない場合
					{
				if (map[qx][qy - 1] == 254)	//さらにマップが過去に更新されていない場合
						{
					map[qx][qy - 1] = map[qx][qy] + 1;
					q[tail] = (qx * 16 + qy - 1);     // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qx > 0 && map[x][y + 1] != 255)     // 西側を見て未知区間にはいかない
				{
			if (is_Exist_Wall(qx, qy, 3) == 0)	//西に壁がない場合
					{
				if (map[qx - 1][qy] == 254)	//さらにマップが過去に更新されていない場合
						{
					map[qx - 1][qy] = map[qx][qy] + 1;
					q[tail] = ((qx - 1) * 16 + qy);     // 次の区画の座標を記憶
					tail++;     // 情=報を入れたので末尾位置をずらす

				}
			}
		}
	}

}

void q_NOT_short_map_maker(int hikisuu_goal_x, int hikisuu_goal_y) { //0地点がゴール座標に設定されている上でのお話！
	for (qx = 0; qx <= x_size; qx++)		// 未探索区間の初期化,255を代入
			{
		for (qy = 0; qy <= y_size; qy++) {
			if (hasReached(qx, qy) == 0 || hasReached(qx, qy) == 10) {
				map[qx][qy] = 255;

			} else if (hasReached(qx, qy) == 1) {
				map[qx][qy] = 254;
			}
		}
	}

	map[hikisuu_goal_x][hikisuu_goal_y] = 0;			// ゴール地点に距離０を書き込む
	q_s[0] = (1 * 4096 + 4 * 256 + hikisuu_goal_x * 16 + hikisuu_goal_y);// flag,ゴール地点の座標を記憶,4であるので東向きに出発するつもり
	head = 0;							// 先頭位置を初期化
	tail = 1;							// 末尾位置は、最後の情報位置＋１

	while (head != tail)				// 配列の中身が空ならループを抜ける（更新できないとループを抜ける）
	{
		qy = q_s[head] & 0x000f;       		// 配列から区画のy座標を取り出す
		qx = q_s[head] & 0x00ff >> 4;		//　配列から区画のx座標を取り出す
		direction_number = q_s[head] >> 8;		// 配列から区画の方向を取り出す（初期値は4で東）
		renewal_flag = q_s[head] >> 12;		//書き換えのフラグ
		head++;							// 情報を取り出したので先頭位置をずらす

		if (qy < y_size && map[qx][qy] < 255)							// 北側をみる
				{
//			if (map[qx][qy+1] > map[qx][qy])	//北が探索済みの場合

			if (renewal_flag == 0)				//まだ書き換えられていない場合
					{
				if (direction_number == 8)	//さらに現在マップの前のマップが北方向の場合
						{
					map[qx][qy + 1] = map[qx][qy] + 1;		//次のマップは同じ方向より＋1
					q_s[tail] = (1 * 4096 + 8 * 256 + qx * 16 + qy + 1); // 次の区画の座標、方向を記憶
					tail++;     // 情報を入れたので末尾位置をずらす
				} else {
					map[qx][qy + 1] = map[qx][qy] + 2;		//次のマップは別の方向だから＋2
					q_s[tail] = (1 * 4096 + 8 * 256 + qx * 16 + qy + 1); // 次の区画の座標、方向を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qx < x_size && map[qx][qy] < 255)     // 東側
				{
//			if (map[qx+1][qy] > map[qx][qy])	//東が探索済みの場合

			if (renewal_flag == 0)				//まだ書き換えられていない場合
					{
				if (direction_number == 4)	//さらに現在マップの前のマップが東方向の場合
						{
					map[qx + 1][qy] = map[qx][qy] + 1;		//次のマップは同じ方向だから＋1
					q_s[tail] = (1 * 4096 + 4 * 256 + (qx + 1) * 16 + qy); // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす
				} else {
					map[qx + 1][qy] = map[qx][qy] + 2;		//次のマップは別の方向だから＋2
					q_s[tail] = (1 * 4096 + 4 * 256 + (qx + 1) * 16 + qy); // 次の区画の座標、方向を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qy > 0 && map[qx][qy] < 255)     // 南側
				{
//			if (map[qx][qy-1] > map[qx][qy])	//南に壁がない場合

			if (renewal_flag == 0)				//まだ書き換えられていない場合
					{
				if (direction_number == 2)	//さらにマップが過去に更新されていない場合
						{
					map[qx][qy - 1] = map[qx][qy] + 1;
					q_s[tail] = (1 * 4096 + 2 * 256 + qx * 16 + qy - 1); // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				} else {
					map[qx][qy - 1] = map[qx][qy] + 2;
					q_s[tail] = (1 * 4096 + 2 * 256 + qx * 16 + qy - 1); // 次の区画の座標を記憶
					tail++;     // 情報を入れたので末尾位置をずらす

				}
			}
		}
		if (qx > 0 && map[qx][qy] < 255)     // 西側
				{
//			if (map[qx-1][qy] > map[qx][qy])	//西に壁がない場合
			if (renewal_flag == 0)				//まだ書き換えられていない場合
					{
				if (direction_number == 1)	//さらにマップが過去に更新されていない場合
						{
					map[qx - 1][qy] = map[qx][qy] + 1;
					q_s[tail] = (1 * 4096 + 1 * 256 + (qx - 1) * 16 + qy); // 次の区画の座標を記憶
					tail++;     // 情=報を入れたので末尾位置をずらす

				} else {
					map[qx - 1][qy] = map[qx][qy] + 2;
					q_s[tail] = (1 * 4096 + 1 * 256 + (qx - 1) * 16 + qy); // 次の区画の座標を記憶
					tail++;     // 情=報を入れたので末尾位置をずらす

				}
			}
		}
	}

}
void adachihou_q2_slalom(int hikisuu_goal_x, int hikisuu_goal_y, int start_x,
		int start_y, int V_search, int ACCEL_search, float hikisuu_angacc,
		float hikisuu_angle1_r, float hikisuu_angle2_r, float hikisuu_angle1_l,
		float hikisuu_angle2_l, float offset_r1, float offset_r2,
		float offset_l1, float offset_l2) {    //正常な足立法。
	colum2[0] |= 1;

//	colum[0] = 1;	←これやばいやつ！
//	direction_count = 0;
	footmark[0][0] = 1;

	x = start_x;
	y = start_y;
	direction_xy();		//スタート方向に初期値＋1する.これでスタート座標を直接代入できる
//	q_walk_map2_maker(hikisuu_goal_x, hikisuu_goal_y);
	motor_enable = 1;
	wait(300); 			//励磁直後は少し待つ！
	PE.DRL.BIT.B0 = 0;	//B0=0で正回転
	PE.DRL.BIT.B4 = 1;	//B4=1で正回転
	distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
	setReached(x, y);
	watched_wall_front_2(0, 0, 0);		//初期に読めない壁だが、読んだことにする
	watched_wall_right_2(0, 0, 0);		//初期に読めない壁だが、読んだことにする



	while (1) {
		if (map2[x][y] == 255) {		//閉じ込められたら自動で抜け出す。
			accident_flag = 1;
		}

		total_dist = 0.0;	//スラローム関数の前にはこれが必要

		if (SEN_r_front_value > 850 && SEN_l_front_value > 850
				&& clash_count >= 1) {		//ぶつかり続けるとカウント追加
			clash_count++;
			if (clash_count >= 3) {
				accident_flag = 1;
			}
		} else {
			clash_count = 0;
		}
		if (accident_flag == 1) {
			break;
		}
		if (SEN_r_front_value >= r_front_wall_judge) {	//前センサーの壁判断
			add_wall_front_2(x, y, direction_count);
		}
		if (SEN_r_value >= r_wall_judge) {	//右センサーの壁判断
			add_wall_right_2(x, y, direction_count);
		}
		if (SEN_l_value >= l_wall_judge) {	//左センサーの壁判断
			add_wall_left_2(x, y, direction_count);
		}
		watched_wall_front_2(x, y, direction_count);
		watched_wall_right_2(x, y, direction_count);
		watched_wall_left_2(x, y, direction_count);

		if (x == goal_x && y == goal_y) {		//以下、クシつぶし

		} else if (x == goal_x + 1 && y == goal_y) {

		} else if (x == goal_x + 1 && y == goal_y + 1) {

		} else if (x == goal_x && y == goal_y + 1) {
		} else {

			if (x > 0 && y < 15 && is_the_Wall_watched_2(x, y, 3) == 1	//左上横壁追加
			&& is_the_Wall_watched_2(x, y + 1, 3) == 1
					&& is_the_Wall_watched_2(x, y, 0) == 1
					&& is_Exist_Wall_2(x, y, 3) == 0
					&& is_Exist_Wall_2(x, y + 1, 3) == 0
					&& is_Exist_Wall_2(x, y, 0) == 0
					&& is_the_Wall_watched_2(x - 1, y, 0) == 0) {
				add_wall_front_2(x - 1, y, 0);
				watched_wall_front_2(x - 1, y, 0);
			}
			if (x < 15 && y < 15 && is_the_Wall_watched_2(x, y, 1) == 1	//右上横壁追加
			&& is_the_Wall_watched_2(x, y + 1, 1) == 1
					&& is_the_Wall_watched_2(x, y, 0) == 1
					&& is_Exist_Wall_2(x, y, 1) == 0
					&& is_Exist_Wall_2(x, y + 1, 1) == 0
					&& is_Exist_Wall_2(x, y, 0) == 0
					&& is_the_Wall_watched_2(x + 1, y, 0) == 0) {
				add_wall_front_2(x + 1, y, 0);
				watched_wall_front_2(x + 1, y, 0);
			}
			if (x < 15 && y > 0 && is_the_Wall_watched_2(x, y, 1) == 1	//右下横壁追加
			&& is_the_Wall_watched_2(x, y - 1, 1) == 1
					&& is_the_Wall_watched_2(x, y, 2) == 1
					&& is_Exist_Wall_2(x, y, 1) == 0
					&& is_Exist_Wall_2(x, y - 1, 1) == 0
					&& is_Exist_Wall_2(x, y, 2) == 0
					&& is_the_Wall_watched_2(x + 1, y - 1, 0) == 0) {
				add_wall_front_2(x + 1, y - 1, 0);
				watched_wall_front_2(x + 1, y - 1, 0);
			}
			if (x > 0 && y > 0 && is_the_Wall_watched_2(x, y, 3) == 1	//左下横壁追加
			&& is_the_Wall_watched_2(x, y - 1, 3) == 1
					&& is_the_Wall_watched_2(x, y, 2) == 1
					&& is_Exist_Wall_2(x, y, 3) == 0
					&& is_Exist_Wall_2(x, y - 1, 3) == 0
					&& is_Exist_Wall_2(x, y, 2) == 0
					&& is_the_Wall_watched_2(x - 1, y - 1, 0) == 0) {
				add_wall_front_2(x - 1, y - 1, 0);
				watched_wall_front_2(x - 1, y - 1, 0);
			}
			if (x > 0 && y < 15 && is_the_Wall_watched_2(x - 1, y, 0) == 1//左上縦壁追加
			&& is_the_Wall_watched_2(x, y, 0) == 1
					&& is_the_Wall_watched_2(x, y, 3) == 1
					&& is_Exist_Wall_2(x - 1, y, 0) == 0
					&& is_Exist_Wall_2(x, y, 0) == 0
					&& is_Exist_Wall_2(x, y, 3) == 0
					&& is_the_Wall_watched_2(x, y + 1, 3) == 0) {
				add_wall_left_2(x, y + 1, 0);
				watched_wall_left_2(x, y + 1, 0);
			}
			if (x < 15 && y < 15 && is_the_Wall_watched_2(x, y, 0) == 1	//右上縦壁追加
			&& is_the_Wall_watched_2(x + 1, y, 0) == 1
					&& is_the_Wall_watched_2(x, y, 1) == 1
					&& is_Exist_Wall_2(x, y, 0) == 0
					&& is_Exist_Wall_2(x + 1, y, 0) == 0
					&& is_Exist_Wall_2(x, y, 1) == 0
					&& is_the_Wall_watched_2(x, y + 1, 1) == 0) {
				add_wall_right_2(x, y + 1, 0);
				watched_wall_right_2(x, y + 1, 0);
			}
			if (x < 15 && y > 0 && is_the_Wall_watched_2(x, y, 2) == 1	//右下縦壁追加
			&& is_the_Wall_watched_2(x + 1, y, 2) == 1
					&& is_the_Wall_watched_2(x, y, 1) == 1
					&& is_Exist_Wall_2(x, y, 2) == 0
					&& is_Exist_Wall_2(x + 1, y, 2) == 0
					&& is_Exist_Wall_2(x, y, 1) == 0
					&& is_the_Wall_watched_2(x, y - 1, 1) == 0) {
				add_wall_right_2(x, y - 1, 0);
				watched_wall_right_2(x, y - 1, 0);
			}
			if (x > 0 && y > 0 && is_the_Wall_watched_2(x - 1, y, 2) == 1//左下縦壁追加
			&& is_the_Wall_watched_2(x, y, 2) == 1
					&& is_the_Wall_watched_2(x, y, 3) == 1
					&& is_Exist_Wall_2(x - 1, y, 2) == 0
					&& is_Exist_Wall_2(x, y, 2) == 0
					&& is_Exist_Wall_2(x, y, 3) == 0
					&& is_the_Wall_watched_2(x, y - 1, 3) == 0) {
				add_wall_left_2(x, y - 1, 0);
				watched_wall_left_2(x, y - 1, 0);
			}
		}
//		LED2_y = 1;
		q_walk_map2_maker(hikisuu_goal_x, hikisuu_goal_y);
//		LED2_y = 0;
		switch (direction_count) {
		case 0:
			if (y < 15&& map2[x][y + 1]
			< map2[x][y]&& SEN_r_front_value < r_front_wall_judge) {//North & 直進
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 2;
				distance_q(180.0, V_search, ACCEL_search, V_search, V_search,
						1);
				direction_xy();

			} else if (x < 15&& map2[x + 1][y]
			< map2[x][y]&& SEN_r_value < r_wall_judge) {	//North & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}
				LED1_p = 1;
				slalom_R2(90, hikisuu_angacc, hikisuu_angle1_r,
						hikisuu_angle2_r, V_search, offset_r1, offset_r2, 1);//右折//(角度、最高角速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
				direction_xy();
				LED1_p = 0;
			} else if (x > 0&& map2[x - 1][y]
			< map2[x][y]&& SEN_l_value < l_wall_judge) {	//North & 左折

				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}

				slalom_L2(90, hikisuu_angacc, hikisuu_angle1_l,
						hikisuu_angle2_l, V_search, offset_l1, offset_l2, 1);//左折
				direction_xy();
			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 1;
				distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(STOP_count);
				turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(STOP_count);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 2;
				distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
				direction_xy();
				footmark[x][y] = 10;
			}
			break;

		case 1:
			if (x
					< 15&& map2[x+1][y] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//East & 直進
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 2;
				distance_q(180.0, V_search, ACCEL_search, V_search, V_search,
						1);
				direction_xy();

			} else if (y
					> 0&& map2[x][y-1] < map2[x][y] && SEN_r_value < r_wall_judge) {//East & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}
				LED1_p = 1;
				slalom_R2(90, hikisuu_angacc, hikisuu_angle1_r,
						hikisuu_angle2_r, V_search, offset_r1, offset_r2, 1);//右折//(角度、最高角速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
				direction_xy();
				LED1_p = 0;

			} else if (y
					< 15&& map2[x][y+1] < map2[x][y] && SEN_l_value < l_wall_judge) {//East & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}
				LED1_p = 1;
				slalom_L2(90, hikisuu_angacc, hikisuu_angle1_l,
						hikisuu_angle2_l, V_search, offset_l1, offset_l2, 1);//左折
				direction_xy();
				LED1_p = 0;
			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 1;
				distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(STOP_count);
				turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(STOP_count);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 2;
				distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
				direction_xy();
				footmark[x][y] = 10;

			}
			break;

		case 2:
			if (y
					> 0&& map2[x][y-1] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 2;
				distance_q(180.0, V_search, ACCEL_search, V_search, V_search,
						1);
				direction_xy();
			} else if (x
					> 0&& map2[x-1][y] < map2[x][y] && SEN_r_value < r_wall_judge) {//South & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}

				slalom_R2(90, hikisuu_angacc, hikisuu_angle1_r,
						hikisuu_angle2_r, V_search, offset_r1, offset_r2, 1);//右折//(角度、最高角速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
				direction_xy();

			} else if (x
					< 15&& map2[x+1][y] < map2[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}

				slalom_L2(90, hikisuu_angacc, hikisuu_angle1_l,
						hikisuu_angle2_l, V_search, offset_l1, offset_l2, 1);//左折
				direction_xy();

			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 1;
				distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(STOP_count);
				turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(STOP_count);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 2;
				distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
				direction_xy();
				footmark[x][y] = 10;

			}
			break;

		case 3:
			if (x
					> 0&& map2[x-1][y] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進
				direction_xy();
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 2;
				distance_q(180.0, V_search, ACCEL_search, V_search, V_search,
						1);
			} else if (y
					< 15&& map2[x][y+1] < map2[x][y] && SEN_r_value < r_wall_judge) {//West & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}

				slalom_R2(90, hikisuu_angacc, hikisuu_angle1_r,
						hikisuu_angle2_r, V_search, offset_r1, offset_r2, 1);//右折//(角度、最高角速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
				direction_xy();

			} else if (y
					> 0&& map2[x][y-1] < map2[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}

				slalom_L2(90, hikisuu_angacc, hikisuu_angle1_l,
						hikisuu_angle2_l, V_search, offset_l1, offset_l2, 1);//左折
				direction_xy();

			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 1;
				distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(STOP_count);
				turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(STOP_count);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				interrupt_kabekire = 2;
				distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
				direction_xy();
				footmark[x][y] = 10;

			}
			break;

		}
		setReached(x, y);

		if (x == hikisuu_goal_x && y == hikisuu_goal_y) {
			break;
		}

	}
	if (accident_flag == 0) {
		distance3(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
		MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		wait(300);
		motor_enable = 0;
	} else {
		motor_enable = 0;
	}
}


void make_pass(int hikisuu_goal_x, int hikisuu_goal_y) {		//パスの作成（簡易版）
	colum[0] |= 1;
//	colum[0] = 1;
	direction_count = 0;		//スタート地点を考えている。
	footmark[0][0] = 1;
	straight_count = 0;
	x = 0;
	y = 1;
	p_i = 0;
	pass[0] = 255;

	while (1) {
		switch (direction_count) {
		case 0:
			if (y < 15 && map[x][y + 1] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 0) == 0) {	//North & 直進
				direction_xy();
				if (pass[p_i] <= 30) {
					pass[p_i] = pass[p_i] + 2;
				} else {
					p_i++;
					pass[p_i] = 2;
				}
			} else if (x < 15 && map[x + 1][y] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 1) == 0) {	//North & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}
				direction_xy();
				p_i++;
				pass[p_i] = 40;
			} else if (x > 0 && map[x - 1][y] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 3) == 0) {	//North & 左折

				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}
				direction_xy();
				p_i++;
				pass[p_i] = 50;
			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}
				direction_xy();

			}
			break;

		case 1:
			if (x < 15 && map[x + 1][y] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 1) == 0) {	//East & 直進
				direction_xy();
				if (pass[p_i] <= 30) {
					pass[p_i] = pass[p_i] + 2;
				} else {
					p_i++;
					pass[p_i] = 2;
				}
			} else if (y > 0 && map[x][y - 1] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 2) == 0) {	//East & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}
				direction_xy();
				p_i++;
				pass[p_i] = 40;

			} else if (y < 15 && map[x][y + 1] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 0) == 0) {	//East & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}
				direction_xy();
				p_i++;
				pass[p_i] = 50;
			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}
				direction_xy();
			}
			break;

		case 2:
			if (y > 0 && map[x][y - 1] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 2) == 0) {	//South & 直進
				direction_xy();
				if (pass[p_i] <= 30) {
					pass[p_i] = pass[p_i] + 2;
				} else {
					p_i++;
					pass[p_i] = 2;
				}

			} else if (x > 0 && map[x - 1][y] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 3) == 0) {	//South & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}
				direction_xy();
				p_i++;
				pass[p_i] = 40;
			} else if (x < 15 && map[x + 1][y] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 1) == 0) {	//South & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}
				direction_xy();
				p_i++;
				pass[p_i] = 50;
			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}
				direction_xy();
			}
			break;

		case 3:
			if (x > 0 && map[x - 1][y] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 3) == 0) {	//West & 直進
				direction_xy();
				if (pass[p_i] <= 30) {
					pass[p_i] = pass[p_i] + 2;
				} else {
					p_i++;
					pass[p_i] = 2;
				}

			} else if (y < 15 && map[x][y + 1] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 0) == 0) {	//West & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}
				direction_xy();
				p_i++;
				pass[p_i] = 40;
			} else if (y > 0 && map[x][y - 1] == map[x][y] - 1
					&& is_Exist_Wall(x, y, 2) == 0) {	//West & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}
				direction_xy();
				p_i++;
				pass[p_i] = 50;
			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}
				direction_xy();
			}
			break;

		}
		if (x == hikisuu_goal_x && y == hikisuu_goal_y) {
			last_p_i = p_i;
			break;
		}

	}
}
void convert_pass() {
	read_p_i = 0;
	con_p_i = 0;
	while (1) {

		/*		if (pass[read_p_i] >= 1 && pass[read_p_i] <= 15
		 && pass[read_p_i + 1] == 20	//パターン(1)右ターン右ターン
		 && pass[read_p_i + 2] == 1 && pass[read_p_i + 3] <= 20
		 && pass[read_p_i + 4] <= 15 && pass[read_p_i + 4] >= 1) {
		 pass[read_p_i]--;
		 pass[read_p_i + 1] = 0;
		 pass[read_p_i + 2] = 241;	//パターン(1)
		 pass[read_p_i + 3] = 0;
		 pass[read_p_i + 4]--;
		 read_p_i = read_p_i + 4;	//次はここから読む
		 } else if (pass[read_p_i] >= 1 && pass[read_p_i] <= 15
		 && pass[read_p_i + 1] == 30	//パターン(2)左ターン左ターン
		 && pass[read_p_i + 2] == 1 && pass[read_p_i + 3] <= 30
		 && pass[read_p_i + 4] <= 15 && pass[read_p_i + 4] >= 1) {
		 pass[read_p_i]--;
		 pass[read_p_i + 1] = 0;
		 pass[read_p_i + 2] = 242;	//パターン(2)
		 pass[read_p_i + 3] = 0;
		 pass[read_p_i + 4]--;
		 read_p_i = read_p_i + 4;	//次はここから読む
		 } else if (pass[read_p_i] >= 1 && pass[read_p_i] <= 15
		 && pass[read_p_i + 1] == 20	//パターン(3)右ターン左ターン
		 && pass[read_p_i + 2] == 1 && pass[read_p_i + 3] <= 30
		 && pass[read_p_i + 4] <= 15 && pass[read_p_i + 4] >= 1) {
		 pass[read_p_i]--;
		 pass[read_p_i + 1] = 0;
		 pass[read_p_i + 2] = 243;	//パターン(2)
		 pass[read_p_i + 3] = 0;
		 pass[read_p_i + 4]--;
		 read_p_i = read_p_i + 4;	//次はここから読む
		 } else if (pass[read_p_i] >= 1 && pass[read_p_i] <= 15
		 && pass[read_p_i + 1] == 30	//パターン(4)左ターン右ターン
		 && pass[read_p_i + 2] == 1 && pass[read_p_i + 3] <= 20
		 && pass[read_p_i + 4] <= 15 && pass[read_p_i + 4] >= 1) {
		 pass[read_p_i]--;
		 pass[read_p_i + 1] = 0;
		 pass[read_p_i + 2] = 244;	//パターン(4)
		 pass[read_p_i + 3] = 0;
		 pass[read_p_i + 4]--;
		 read_p_i = read_p_i + 4;	//次はここから読む
		 } else
		 */if (pass[read_p_i] >= 1 && pass[read_p_i] <= 30
				&& pass[read_p_i + 1] == 40 && pass[read_p_i + 2] <= 30
				&& pass[read_p_i + 2] >= 1) {	//右の大廻ターンの場合
			pass[read_p_i]--;
			pass[read_p_i + 1] = 220;
			pass[read_p_i + 2]--;
			read_p_i = read_p_i + 2;	//
		} else if (pass[read_p_i] >= 1 && pass[read_p_i] <= 30
				&& pass[read_p_i + 1] == 50 && pass[read_p_i + 2] <= 30
				&& pass[read_p_i + 2] >= 1) {	//左の大廻ターンの場合
			pass[read_p_i]--;
			pass[read_p_i + 1] = 230;
			pass[read_p_i + 2]--;
			read_p_i = read_p_i + 2;	//
		} else if (pass[read_p_i] >= 1 && pass[read_p_i] <= 30
				&& pass[read_p_i + 1] == 40 && pass[read_p_i + 2] == 40
				&& pass[read_p_i + 3] <= 30 && pass[read_p_i + 3] >= 1) {//右の180度ターンの場合
			pass[read_p_i]--;
			pass[read_p_i + 1] = 225;
			pass[read_p_i + 2] = 0;
			pass[read_p_i + 3]--;
			read_p_i = read_p_i + 3;
		} else if (pass[read_p_i] >= 1 && pass[read_p_i] <= 30
				&& pass[read_p_i + 1] == 50 && pass[read_p_i + 2] == 50
				&& pass[read_p_i + 3] <= 30 && pass[read_p_i + 3] >= 1) {//右の180度ターンの場合
			pass[read_p_i]--;
			pass[read_p_i + 1] = 235;
			pass[read_p_i + 2] = 0;
			pass[read_p_i + 3]--;
			read_p_i = read_p_i + 3;
		} else if (pass[read_p_i] >= 1 && pass[read_p_i] <= 30
				&& pass[read_p_i + 1] == 40) {	//直進からの減速右ターン
			pass[read_p_i]--;
			pass[read_p_i + 1] = 204;
			read_p_i = read_p_i + 1;
		} else if (pass[read_p_i] >= 1 && pass[read_p_i] <= 30
				&& pass[read_p_i + 1] == 50) {	//直進からの減速左ターン
			pass[read_p_i]--;
			pass[read_p_i + 1] = 205;
			read_p_i = read_p_i + 1;
		} else if (pass[read_p_i] == 40 && pass[read_p_i + 1] >= 1
				&& pass[read_p_i + 1] <= 30) {	//直進からの減速右ターン
			pass[read_p_i] = 214;
			pass[read_p_i + 1]--;
			read_p_i = read_p_i + 1;
		} else if (pass[read_p_i] == 50 && pass[read_p_i + 1] >= 1
				&& pass[read_p_i + 1] <= 30) {	//直進からの減速右ターン
			pass[read_p_i] = 215;
			pass[read_p_i + 1]--;
			read_p_i = read_p_i + 1;
		} else {
			read_p_i++;
		}
		if (read_p_i - 1 == last_p_i) {
			break;
		}
	}
	last_p_i = read_p_i - 1;	//変換後のpass[]を最後の値とする
}
void read_pass(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel) {
	read_p_i = 0;

	motor_enable = 1;
	wait(300); 			//励磁直後は少し待つ！
	PE.DRL.BIT.B0 = 0;	//B0=0で正回転
	PE.DRL.BIT.B4 = 1;	//B4=1で正回転
	if (pass[1] == 40) {
		distance4(90.0, 480, hikisuu_accel, 150.0, 480, 1);
	} else if (pass[1] == 50) {
		distance4(90.0, 480, hikisuu_accel, 150.0, 480, 1);
	} else {
		distance4(90.0, hikisuu_v, hikisuu_accel, 150.0, hikisuu_v, 1);	//最初の90直進
		//	(hikisuu_dist, vmax, hikisuu_accel, v_0, vterm, kabeseigyo)
	}
	while (1) {
		read_p_i++;

		if (pass[read_p_i] <= 30 && pass[read_p_i] >= 1) {	//数値の区間の半分直進
			PE.DRL.BIT.B0 = 0;	//B0=0で正回転
			PE.DRL.BIT.B4 = 1;	//B4=1で正回転
			interrupt_kabekire = 1;	//とりあえず
			distance4(90.0 * pass[read_p_i], hikisuu_vmax, hikisuu_accel,
					hikisuu_v, hikisuu_v, 1);
		} else {
			switch (pass[read_p_i]) {
//			case 255:	//最初の90直進
			case 0:
				break;
			case 40:	//右折
				total_dist = 0;
				slalom_R2(90, 4300, 30.5, 59.5, 480, 6.0, 9.0, 1);//右折//(角度、最高角加速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
				break;
			case 50:	//左折
				total_dist = 0;
				slalom_L2(90, 4300, 30.5, 59.5, 480, 6 + 5.5, 6.0, 1);//右折//(角度、最高角加速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
				break;
			case 220:	//右大廻ターン
				total_dist = 0;
				kabe_cancel = 20;
				slalom_R2(88.5, 4300, 38.5, 50, 750, 54, 66, 1);
//				slalom_R2(89.5, 3500, 27.25, 62.25, 750, 30 - 4, 30, 1);
				break;
			case 230:	//左大廻ターン
				total_dist = 0;
				kabe_cancel = 30;
				slalom_L2(88.5, 4300, 38.5, 50, 750, 57, 58, 1);
//				slalom_L2(89.5, 3500, 27.25, 62.25, 750, 30 + 5.5, 30, 1);
				break;
			case 225:	//右Uターン
				total_dist = 0;
				slalom_R2(175, 3000, 42.5, 132.5, 750, 26, 32, 1);
				break;
			case 235:	//左Uターン
				total_dist = 0;
				slalom_L2(177.8, 2800, 47.8, 130, 750, 35.5, 38, 1);
				break;
			case 204:	//減速+右ターン
				total_dist = 0;
				distance4(90.0, hikisuu_vmax, hikisuu_accel, hikisuu_v, 480, 1);//(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
//				float vterm, int kabeseigyo)
				total_dist = 0;
				slalom_R2(90, 4300, 30.5, 59.5, 480, 6.0, 9.0, 1);
				break;
			case 205:	//減速+左ターン
				total_dist = 0;
				distance4(90.0, hikisuu_vmax, hikisuu_accel, hikisuu_v, 480, 1);
				total_dist = 0;
				slalom_L2(90, 4300, 30.5, 59.5, 480, 6 + 5.5, 6.0, 1);
				break;
			case 214:	//右ターン+加速
				total_dist = 0;
				slalom_R2(90, 4300, 30.5, 59.5, 480, 6.0, 9.0, 1);
				total_dist = 0;
				distance4(90.0, hikisuu_vmax, hikisuu_accel, 480, hikisuu_v, 1);//(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
//				float vterm, int kabeseigyo)
				break;
			case 215:	//左ターン+加速
				total_dist = 0;
				slalom_L2(90, 4300, 30.5, 59.5, 480, 6 + 5.5, 6.0, 1);
				total_dist = 0;
				distance4(90.0, hikisuu_vmax, hikisuu_accel, 480, hikisuu_v, 1);
				break;

			}
		}
		if (read_p_i == last_p_i) {
			break;
		}
	}
	if (pass[last_p_i] == 40) {
		distance4(90.0, 480, hikisuu_accel, 480, 150.0, 1);	//ゴールでの90直進
	} else if (pass[last_p_i] == 50) {
		distance4(90.0, 480, hikisuu_accel, 480, 150.0, 1);	//ゴールでの90直進
	} else {
		distance4(90.0, hikisuu_v, hikisuu_accel, hikisuu_v, 150.0, 1);	//ゴールでの90直進
	}
	MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ(モーター回転開始)
	wait(300);
	motor_enable = 0;
}
void read_pass_b(float hikisuu_vmax, float hikisuu_v, float hikisuu_accel) {//重心速度は800
	read_p_i = 0;

	motor_enable = 1;
	wait(300); 			//励磁直後は少し待つ！
	PE.DRL.BIT.B0 = 0;	//B0=0で正回転
	PE.DRL.BIT.B4 = 1;	//B4=1で正回転
	if (pass[1] == 40) {
		distance4(90.0, 480, hikisuu_accel, 150.0, 480, 1);
	} else if (pass[1] == 50) {
		distance4(90.0, 480, hikisuu_accel, 150.0, 480, 1);
	} else {
		distance4(90.0, hikisuu_v, hikisuu_accel, 150.0, hikisuu_v, 1);	//最初の90直進
		//	(hikisuu_dist, vmax, hikisuu_accel, v_0, vterm, kabeseigyo)
	}
	while (1) {
		read_p_i++;

		if (pass[read_p_i] <= 30 && pass[read_p_i] >= 1) {	//数値の区間の半分直進
			PE.DRL.BIT.B0 = 0;	//B0=0で正回転
			PE.DRL.BIT.B4 = 1;	//B4=1で正回転
			interrupt_kabekire = 1;	//とりあえず
			distance4(90.0 * pass[read_p_i], hikisuu_vmax, hikisuu_accel,
					hikisuu_v, hikisuu_v, 1);
		} else {
			switch (pass[read_p_i]) {
//			case 255:	//最初の90直進
			case 0:
				break;
			case 40:	//右折
				total_dist = 0;
				slalom_R2(90, 4300, 30.5, 59.5, 480, 6.0, 9.0, 1);//右折//(角度、最高角加速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
				break;
			case 50:	//左折
				total_dist = 0;
				slalom_L2(90, 4300, 30.5, 59.5, 480, 6 + 5.5, 6.0, 1);//右折//(角度、最高角加速度、円弧開始角、円弧終了角、重心速度、オフセット、壁制御)
				break;
			case 220:	//右大廻ターン
				total_dist = 0;
				slalom_R2(88, 4300, 38, 50, 800, 41, 58, 1);
//				slalom_R2(90, 3400, 42, 48, 800, 29 - 4, 29, 1);
				break;
			case 230:	//左大廻ターン
				total_dist = 0;
				slalom_L2(90, 3400, 42, 48, 800, 29 + 5.5, 29, 1);
//				slalom_L2(92, 1500, 31, 61, 550, 105 - 90, 0);
				break;
			case 225:	//右Uターン
				total_dist = 0;
				slalom_R2(178, 3100, 45, 133, 800, 26, 34, 1);
				break;
			case 235:	//左Uターン
				total_dist = 0;
				slalom_L2(178, 3300, 45, 133, 800, 26, 34, 1);
				break;
			case 204:	//減速+右ターン
				total_dist = 0;
				distance4(90.0, hikisuu_vmax, hikisuu_accel, hikisuu_v, 480, 1);//(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
//				float vterm, int kabeseigyo)
				total_dist = 0;
				slalom_R2(90, 4300, 30.5, 59.5, 480, 6.0, 9.0, 1);
				break;
			case 205:	//減速+左ターン
				total_dist = 0;
				distance4(90.0, hikisuu_vmax, hikisuu_accel, hikisuu_v, 480, 1);
				total_dist = 0;
				slalom_L2(90, 4300, 30.5, 59.5, 480, 6 + 5.5, 6.0, 1);
				break;
			case 214:	//右ターン+加速
				total_dist = 0;
				slalom_R2(90, 4300, 30.5, 59.5, 480, 6.0, 9.0, 1);
				total_dist = 0;
				distance4(90.0, hikisuu_vmax, hikisuu_accel, 480, hikisuu_v, 1);//(float hikisuu_dist, float vmax, float hikisuu_accel, float v_0,
//				float vterm, int kabeseigyo)
				break;
			case 215:	//左ターン+加速
				total_dist = 0;
				slalom_L2(90, 4300, 30.5, 59.5, 480, 6 + 5.5, 6.0, 1);
				total_dist = 0;
				distance4(90.0, hikisuu_vmax, hikisuu_accel, 480, hikisuu_v, 1);
				break;

			}
		}
		if (read_p_i == last_p_i) {
			break;
		}
	}
	if (pass[last_p_i] == 40) {
		distance4(90.0, 480, hikisuu_accel, 480, 150.0, 1);	//ゴールでの90直進
	} else if (pass[last_p_i] == 50) {
		distance4(90.0, 480, hikisuu_accel, 480, 150.0, 1);	//ゴールでの90直進
	} else {
		distance4(90.0, hikisuu_v, hikisuu_accel, hikisuu_v, 150.0, 1);	//ゴールでの90直進
	}
	MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ(モーター回転開始)
	MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ(モーター回転開始)
	wait(300);
	motor_enable = 0;
}

/*void adachihou_q2(int hikisuu_goal_x, int hikisuu_goal_y, int start_x,
 int start_y, int V_search, int ACCEL_search) {		//正常な足立法。
 colum2[0] |= 1;
 //	colum[0] = 1;	←これやばいやつ！
 //	direction_count = 0;
 footmark[0][0] = 1;

 x = start_x;
 y = start_y;
 motor_enable = 1;
 wait(300); 			//励磁直後は少し待つ！
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 setReached(x, y);
 watched_wall_front_2(0, 0, 0);		//初期に読めない壁だが、読んだことにする
 watched_wall_right_2(0, 0, 0);		//初期に読めない壁だが、読んだことにする

 while (1) {
 if (map2[x][y] == 255) {		//閉じ込められたら自動で抜け出す。
 accident_flag = 1;
 }
 if (SEN_r_front_value > 850 && SEN_l_front_value > 850
 && clash_count >= 1) {		//ぶつかり続けるとカウント追加
 clash_count++;
 if (clash_count >= 3) {
 accident_flag = 1;
 }
 } else {
 clash_count = 0;
 }
 if (accident_flag == 1) {
 break;
 }
 if (SEN_r_front_value >= r_front_wall_judge) {	//前センサーの壁判断
 add_wall_front_2(x, y, direction_count);
 }
 if (SEN_r_value >= r_wall_judge) {	//右センサーの壁判断
 add_wall_right_2(x, y, direction_count);
 }
 if (SEN_l_value >= l_wall_judge) {	//左センサーの壁判断
 add_wall_left_2(x, y, direction_count);
 }
 watched_wall_front_2(x, y, direction_count);
 watched_wall_right_2(x, y, direction_count);
 watched_wall_left_2(x, y, direction_count);

 if (x == goal_x && y == goal_y) {		//以下、クシつぶし

 } else if (x == goal_x + 1 && y == goal_y) {

 } else if (x == goal_x + 1 && y == goal_y + 1) {

 } else if (x == goal_x && y == goal_y + 1) {
 } else {

 if (x > 0 && y < 15 && is_the_Wall_watched_2(x, y, 3) == 1	//左上横壁追加
 && is_the_Wall_watched_2(x, y + 1, 3) == 1
 && is_the_Wall_watched_2(x, y, 0) == 1
 && is_Exist_Wall_2(x, y, 3) == 0
 && is_Exist_Wall_2(x, y + 1, 3) == 0
 && is_Exist_Wall_2(x, y, 0) == 0
 && is_the_Wall_watched_2(x - 1, y, 0) == 0) {
 add_wall_front_2(x - 1, y, 0);
 watched_wall_front_2(x - 1, y, 0);
 }
 if (x < 15 && y < 15 && is_the_Wall_watched_2(x, y, 1) == 1	//右上横壁追加
 && is_the_Wall_watched_2(x, y + 1, 1) == 1
 && is_the_Wall_watched_2(x, y, 0) == 1
 && is_Exist_Wall_2(x, y, 1) == 0
 && is_Exist_Wall_2(x, y + 1, 1) == 0
 && is_Exist_Wall_2(x, y, 0) == 0
 && is_the_Wall_watched_2(x + 1, y, 0) == 0) {
 add_wall_front_2(x + 1, y, 0);
 watched_wall_front_2(x + 1, y, 0);
 }
 if (x < 15 && y > 0 && is_the_Wall_watched_2(x, y, 1) == 1	//右下横壁追加
 && is_the_Wall_watched_2(x, y - 1, 1) == 1
 && is_the_Wall_watched_2(x, y, 2) == 1
 && is_Exist_Wall_2(x, y, 1) == 0
 && is_Exist_Wall_2(x, y - 1, 1) == 0
 && is_Exist_Wall_2(x, y, 2) == 0
 && is_the_Wall_watched_2(x + 1, y - 1, 0) == 0) {
 add_wall_front_2(x + 1, y - 1, 0);
 watched_wall_front_2(x + 1, y - 1, 0);
 }
 if (x > 0 && y > 0 && is_the_Wall_watched_2(x, y, 3) == 1	//左下横壁追加
 && is_the_Wall_watched_2(x, y - 1, 3) == 1
 && is_the_Wall_watched_2(x, y, 2) == 1
 && is_Exist_Wall_2(x, y, 3) == 0
 && is_Exist_Wall_2(x, y - 1, 3) == 0
 && is_Exist_Wall_2(x, y, 2) == 0
 && is_the_Wall_watched_2(x - 1, y - 1, 0) == 0) {
 add_wall_front_2(x - 1, y - 1, 0);
 watched_wall_front_2(x - 1, y - 1, 0);
 }
 if (x > 0 && y < 15 && is_the_Wall_watched_2(x - 1, y, 0) == 1//左上縦壁追加
 && is_the_Wall_watched_2(x, y, 0) == 1
 && is_the_Wall_watched_2(x, y, 3) == 1
 && is_Exist_Wall_2(x - 1, y, 0) == 0
 && is_Exist_Wall_2(x, y, 0) == 0
 && is_Exist_Wall_2(x, y, 3) == 0
 && is_the_Wall_watched_2(x, y + 1, 3) == 0) {
 add_wall_left_2(x, y + 1, 0);
 watched_wall_left_2(x, y + 1, 0);
 }
 if (x < 15 && y < 15 && is_the_Wall_watched_2(x, y, 0) == 1	//右上縦壁追加
 && is_the_Wall_watched_2(x + 1, y, 0) == 1
 && is_the_Wall_watched_2(x, y, 1) == 1
 && is_Exist_Wall_2(x, y, 0) == 0
 && is_Exist_Wall_2(x + 1, y, 0) == 0
 && is_Exist_Wall_2(x, y, 1) == 0
 && is_the_Wall_watched_2(x, y + 1, 1) == 0) {
 add_wall_right_2(x, y + 1, 0);
 watched_wall_right_2(x, y + 1, 0);
 }
 if (x < 15 && y > 0 && is_the_Wall_watched_2(x, y, 2) == 1	//右下縦壁追加
 && is_the_Wall_watched_2(x + 1, y, 2) == 1
 && is_the_Wall_watched_2(x, y, 1) == 1
 && is_Exist_Wall_2(x, y, 2) == 0
 && is_Exist_Wall_2(x + 1, y, 2) == 0
 && is_Exist_Wall_2(x, y, 1) == 0
 && is_the_Wall_watched_2(x, y - 1, 1) == 0) {
 add_wall_right_2(x, y - 1, 0);
 watched_wall_right_2(x, y - 1, 0);
 }
 if (x > 0 && y > 0 && is_the_Wall_watched_2(x - 1, y, 2) == 1//左下縦壁追加
 && is_the_Wall_watched_2(x, y, 2) == 1
 && is_the_Wall_watched_2(x, y, 3) == 1
 && is_Exist_Wall_2(x - 1, y, 2) == 0
 && is_Exist_Wall_2(x, y, 2) == 0
 && is_Exist_Wall_2(x, y, 3) == 0
 && is_the_Wall_watched_2(x, y - 1, 3) == 0) {
 add_wall_left_2(x, y - 1, 0);
 watched_wall_left_2(x, y - 1, 0);
 }
 }

 total_dist = 0.0;

 q_walk_map2_maker(hikisuu_goal_x, hikisuu_goal_y);

 switch (direction_count) {
 case 0:
 if (y < 15&& map2[x][y + 1]
 < map2[x][y]&& SEN_r_front_value < r_front_wall_judge) {//North & 直進
 LED2_y = 1;
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search,
 1);
 direction_xy();

 LED2_y = 0;
 } else if (x < 15&& map2[x + 1][y]
 < map2[x][y]&& SEN_r_value < r_wall_judge) {	//North & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }
 LED1_p = 1;

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 LED1_p = 0;
 } else if (x > 0&& map2[x - 1][y]
 < map2[x][y]&& SEN_l_value < l_wall_judge) {	//North & 左折

 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 } else {
 if (direction_count == 0) {
 direction_count = 2;
 } else if (direction_count == 1) {
 direction_count = 3;
 } else if (direction_count == 2) {
 direction_count = 0;
 } else {
 direction_count = 1;
 }
 LED1_p = 1;

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 footmark[x][y] = 10;

 }
 break;

 case 1:
 if (x
 < 15&& map2[x+1][y] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//East & 直進
 LED1_p = 1;
 LED3_r = 1;
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search,
 1);
 direction_xy();
 LED1_p = 0;
 LED3_r = 0;

 } else if (y
 > 0&& map2[x][y-1] < map2[x][y] && SEN_r_value < r_wall_judge) {//East & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (y
 < 15&& map2[x][y+1] < map2[x][y] && SEN_l_value < l_wall_judge) {//East & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else {
 if (direction_count == 0) {
 direction_count = 2;
 } else if (direction_count == 1) {
 direction_count = 3;
 } else if (direction_count == 2) {
 direction_count = 0;
 } else {
 direction_count = 1;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 footmark[x][y] = 10;

 }
 break;

 case 2:
 if (y
 > 0&& map2[x][y-1] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search,
 1);
 direction_xy();
 } else if (x
 > 0&& map2[x-1][y] < map2[x][y] && SEN_r_value < r_wall_judge) {//South & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (x
 < 15&& map2[x+1][y] < map2[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else {
 if (direction_count == 0) {
 direction_count = 2;
 } else if (direction_count == 1) {
 direction_count = 3;
 } else if (direction_count == 2) {
 direction_count = 0;
 } else {
 direction_count = 1;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 footmark[x][y] = 10;

 }
 break;

 case 3:
 if (x
 > 0&& map2[x-1][y] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進
 direction_xy();
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search,
 1);
 } else if (y
 < 15&& map2[x][y+1] < map2[x][y] && SEN_r_value < r_wall_judge) {//West & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (y
 > 0&& map2[x][y-1] < map2[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else {
 if (direction_count == 0) {
 direction_count = 2;
 } else if (direction_count == 1) {
 direction_count = 3;
 } else if (direction_count == 2) {
 direction_count = 0;
 } else {
 direction_count = 1;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 footmark[x][y] = 10;

 }
 break;

 }
 setReached(x, y);

 if (x == hikisuu_goal_x && y == hikisuu_goal_y) {
 break;
 }

 }
 if (accident_flag == 0) {
 distance3(90.0, V_search, ACCEL_search, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(300);
 motor_enable = 0;
 } else {
 motor_enable = 0;

 }
 }*/

void adachihou_q(int hikisuu_goal_x, int hikisuu_goal_y, int start_x,
		int start_y) {		//正常な足立法。map[][]に直接書きこんでしまう…
	colum[0] |= 1;
//	colum[0] = 1;	←これやばいやつ！
//	direction_count = 0;
	footmark[0][0] = 1;

	x = start_x;
	y = start_y;
	motor_enable = 1;
	wait(300); 			//励磁直後は少し待つ！
	PE.DRL.BIT.B0 = 0;	//B0=0で正回転
	PE.DRL.BIT.B4 = 1;	//B4=1で正回転
	distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
	setReached(x, y);

	while (1) {
		if (accident_flag == 1) {
			break;
		}
		if (SEN_r_front_value >= r_front_wall_judge) {	//前センサーの壁判断
			add_wall_front(x, y, direction_count);
		}
		if (SEN_r_value >= r_wall_judge) {	//右センサーの壁判断
			add_wall_right(x, y, direction_count);
		}
		if (SEN_l_value >= l_wall_judge) {	//左センサーの壁判断
			add_wall_left(x, y, direction_count);
		}
		total_dist = 0.0;

		q_walk_map_maker(hikisuu_goal_x, hikisuu_goal_y);
		switch (direction_count) {
		case 0:
			if (y < 15&& map[x][y + 1]
			< map[x][y]&& SEN_r_front_value < r_front_wall_judge) {	//North & 直進
				LED2_y = 1;
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(180.0, 400.0, 2000.0, 400.0, 400.0, 1);
				direction_xy();

				LED2_y = 0;
			} else if (x < 15&& map[x + 1][y]
			< map[x][y]&& SEN_r_value < r_wall_judge) {	//North & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}
				LED1_p = 1;

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_clock3(90.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();
				LED1_p = 0;
			} else if (x > 0&& map[x - 1][y]
			< map[x][y]&& SEN_l_value < l_wall_judge) {	//North & 左折

				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_unclock3(90.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();
			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}
				LED1_p = 1;

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_clock3(180.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();
				footmark[x][y] = 10;
			}
			break;

		case 1:
			if (x
					< 15&& map[x+1][y] < map[x][y] && SEN_r_front_value < r_front_wall_judge) {	//East & 直進
				LED1_p = 1;
				LED3_r = 1;
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(180.0, 400.0, 2000.0, 400.0, 400.0, 1);
				direction_xy();
				LED1_p = 0;
				LED3_r = 0;

			} else if (y
					> 0&& map[x][y-1] < map[x][y] && SEN_r_value < r_wall_judge) {//East & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_clock3(90.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();

			} else if (y
					< 15&& map[x][y+1] < map[x][y] && SEN_l_value < l_wall_judge) {	//East & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_unclock3(90.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();

			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_clock3(180.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();
				footmark[x][y] = 10;

			}
			break;

		case 2:
			if (y
					> 0&& map[x][y-1] < map[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(180.0, 400.0, 2000.0, 400.0, 400.0, 1);
				direction_xy();
			} else if (x
					> 0&& map[x-1][y] < map[x][y] && SEN_r_value < r_wall_judge) {//South & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_clock3(90.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();

			} else if (x
					< 15&& map[x+1][y] < map[x][y] && SEN_l_value < l_wall_judge) {	//West & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_unclock3(90.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();

			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_clock3(180.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();
				footmark[x][y] = 10;

			}
			break;

		case 3:
			if (x
					> 0&& map[x-1][y] < map[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進
				direction_xy();
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(180.0, 400.0, 2000.0, 400.0, 400.0, 1);
			} else if (y
					< 15&& map[x][y+1] < map[x][y] && SEN_r_value < r_wall_judge) {	//West & 右折
				if (direction_count == 3) {
					direction_count = 0;
				} else {
					direction_count++;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_clock3(90.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();

			} else if (y
					> 0&& map[x][y-1] < map[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
				if (direction_count == 0) {
					direction_count = 3;
				} else {
					direction_count--;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_unclock3(90.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();

			} else {
				if (direction_count == 0) {
					direction_count = 2;
				} else if (direction_count == 1) {
					direction_count = 3;
				} else if (direction_count == 2) {
					direction_count = 0;
				} else {
					direction_count = 1;
				}

				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance_q(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				turn_clock3(180.0, 400.0, 2000.0, 150.0, 150.0);
				MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
				MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
				wait(300);
				PE.DRL.BIT.B0 = 0;	//B0=0で正回転
				PE.DRL.BIT.B4 = 1;	//B4=1で正回転
				distance3(90.0, 400.0, 2000.0, 150.0, 400.0, 1);
				direction_xy();
				footmark[x][y] = 10;

			}
			break;

		}
		setReached(x, y);

//		if (SEN_r_front_value > r_front_wall_judge) {	//前センサーの壁判断
//			add_wall_front(x, y, direction_count);
//		}
//		if (SEN_r_value > r_wall_judge) {	//右センサーの壁判断
//			add_wall_right(x, y, direction_count);
//		}
//		if (SEN_l_value > l_wall_judge) {	//左センサーの壁判断
//			add_wall_left(x, y, direction_count);
//		}
		if (x == hikisuu_goal_x && y == hikisuu_goal_y) {
			break;
		}

	}
	distance3(90.0, 400.0, 2000.0, 400.0, 150.0, 1);
	MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
	MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
	wait(300);
	motor_enable = 0;
}

/*void hurukawahou_q2(int hikisuu_goal_x, int hikisuu_goal_y, int start_x,
 int start_y) {		//足立法を、未探索区間優先にしたもの
 colum[0] |= 1;
 //	colum[0] = 1;	←これやばいやつ！
 //	direction_count = 0;
 footmark[0][0] = 1;

 x = start_x;
 y = start_y;
 motor_enable = 1;
 wait(300); 			//励磁直後は少し待つ！
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 setReached(x, y);

 while (1) {
 if(map2[x][y]==255){		//閉じ込められたら自動で抜け出す。
 accident_flag = 1;
 }
 if(SEN_r_front_value > 850 && SEN_l_front_value>850 && clash_count>=1){		//ぶつかり続けるとカウント追加
 clash_count++;
 if(clash_count>=3){
 accident_flag=1;
 }
 }else{
 clash_count=0;
 }
 if (accident_flag == 1) {
 break;
 }
 if (SEN_r_front_value >= r_front_wall_judge) {	//前センサーの壁判断
 add_wall_front(x, y, direction_count);
 }
 if (SEN_r_value >= r_wall_judge) {	//右センサーの壁判断
 add_wall_right(x, y, direction_count);
 }
 if (SEN_l_value >= l_wall_judge) {	//左センサーの壁判断
 add_wall_left(x, y, direction_count);
 }
 watched_wall_front_2(x, y, direction_count);
 watched_wall_right_2(x, y, direction_count);
 watched_wall_left_2(x, y, direction_count);

 if (x == goal_x && y == goal_y) {		//以下、クシつぶし

 } else if (x == goal_x + 1 && y == goal_y) {

 } else if (x == goal_x + 1 && y == goal_y + 1) {

 } else if (x == goal_x && y == goal_y + 1) {
 } else {

 if (x > 0 && y < 15 && is_the_Wall_watched_2(x, y, 3) == 1	//左上横壁追加
 && is_the_Wall_watched_2(x, y + 1, 3) == 1
 && is_the_Wall_watched_2(x, y, 0) == 1
 && is_Exist_Wall_2(x, y, 3) == 0
 && is_Exist_Wall_2(x, y + 1, 3) == 0
 && is_Exist_Wall_2(x, y, 0) == 0
 && is_the_Wall_watched_2(x - 1, y, 0) == 0) {
 add_wall_front(x - 1, y, 0);
 watched_wall_front_2(x - 1, y, 0);
 }
 if (x < 15 && y < 15 && is_the_Wall_watched_2(x, y, 1) == 1	//右上横壁追加
 && is_the_Wall_watched_2(x, y + 1, 1) == 1
 && is_the_Wall_watched_2(x, y, 0) == 1
 && is_Exist_Wall_2(x, y, 1) == 0
 && is_Exist_Wall_2(x, y + 1, 1) == 0
 && is_Exist_Wall_2(x, y, 0) == 0
 && is_the_Wall_watched_2(x + 1, y, 0) == 0) {
 add_wall_front(x + 1, y, 0);
 watched_wall_front_2(x + 1, y, 0);
 }
 if (x < 15 && y > 0 && is_the_Wall_watched_2(x, y, 1) == 1	//右下横壁追加
 && is_the_Wall_watched_2(x, y - 1, 1) == 1
 && is_the_Wall_watched_2(x, y, 2) == 1
 && is_Exist_Wall_2(x, y, 1) == 0
 && is_Exist_Wall_2(x, y - 1, 1) == 0
 && is_Exist_Wall_2(x, y, 2) == 0
 && is_the_Wall_watched_2(x + 1, y - 1, 0) == 0) {
 add_wall_front(x + 1, y - 1, 0);
 watched_wall_front_2(x + 1, y - 1, 0);
 }
 if (x > 0 && y > 0 && is_the_Wall_watched_2(x, y, 3) == 1		//左下横壁追加
 && is_the_Wall_watched_2(x, y - 1, 3) == 1
 && is_the_Wall_watched_2(x, y, 2) == 1
 && is_Exist_Wall_2(x, y, 3) == 0
 && is_Exist_Wall_2(x, y - 1, 3) == 0
 && is_Exist_Wall_2(x, y, 2) == 0
 && is_the_Wall_watched_2(x - 1, y - 1, 0) == 0) {
 add_wall_front(x - 1, y - 1, 0);
 watched_wall_front_2(x - 1, y - 1, 0);
 }
 if (x > 0 && y < 15 && is_the_Wall_watched_2(x - 1, y, 0) == 1//左上縦壁追加
 && is_the_Wall_watched_2(x, y, 0) == 1
 && is_the_Wall_watched_2(x, y, 3) == 1
 && is_Exist_Wall_2(x - 1, y, 0) == 0
 && is_Exist_Wall_2(x, y, 0) == 0
 && is_Exist_Wall_2(x, y, 3) == 0
 && is_the_Wall_watched_2(x, y + 1, 3) == 0) {
 add_wall_left(x, y + 1, 0);
 watched_wall_left_2(x, y + 1, 0);
 }
 if (x < 15 && y < 15 && is_the_Wall_watched_2(x, y, 0) == 1	//右上縦壁追加
 && is_the_Wall_watched_2(x + 1, y, 0) == 1
 && is_the_Wall_watched_2(x, y, 1) == 1
 && is_Exist_Wall_2(x, y, 0) == 0
 && is_Exist_Wall_2(x + 1, y, 0) == 0
 && is_Exist_Wall_2(x, y, 1) == 0
 && is_the_Wall_watched_2(x, y + 1, 1) == 0) {
 add_wall_right(x, y + 1, 0);
 watched_wall_right_2(x, y + 1, 0);
 }
 if (x < 15 && y > 0 && is_the_Wall_watched_2(x, y, 2) == 1	//右下縦壁追加
 && is_the_Wall_watched_2(x + 1, y, 2) == 1
 && is_the_Wall_watched_2(x, y, 1) == 1
 && is_Exist_Wall_2(x, y, 2) == 0
 && is_Exist_Wall_2(x + 1, y, 2) == 0
 && is_Exist_Wall_2(x, y, 1) == 0
 && is_the_Wall_watched_2(x, y - 1, 1) == 0) {
 add_wall_right(x, y - 1, 0);
 watched_wall_right_2(x, y - 1, 0);
 }
 if (x > 0 && y > 0 && is_the_Wall_watched_2(x - 1, y, 2) == 1	//左下縦壁追加
 && is_the_Wall_watched_2(x, y, 2) == 1
 && is_the_Wall_watched_2(x, y, 3) == 1
 && is_Exist_Wall_2(x - 1, y, 2) == 0
 && is_Exist_Wall_2(x, y, 2) == 0
 && is_Exist_Wall_2(x, y, 3) == 0
 && is_the_Wall_watched_2(x, y - 1, 3) == 0) {
 add_wall_left(x, y - 1, 0);
 watched_wall_left_2(x, y - 1, 0);
 }
 }

 total_dist = 0.0;

 q_walk_map2_maker(hikisuu_goal_x, hikisuu_goal_y);

 switch (direction_count) {
 case 0:
 if (y < 15&& hasReached(x,y+1)==0 && map2[x][y + 1]
 < map2[x][y]&& SEN_r_front_value < r_front_wall_judge) {//North & 直進
 LED2_y = 1;
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, 2000.0, V_search, V_search, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 direction_xy();

 LED2_y = 0;
 } else if (x < 15&& hasReached(x+1,y)==0 && map2[x + 1][y]
 < map2[x][y]&& SEN_r_value < r_wall_judge) {	//North & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }
 LED1_p = 1;

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, 400.0, 1);
 direction_xy();
 LED1_p = 0;
 } else if (x > 0&& hasReached(x-1,y)==0 && map2[x - 1][y]
 < map2[x][y]&& SEN_l_value < l_wall_judge) {	//North & 左折

 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 } else if (y < 15&& map2[x][y + 1]
 < map2[x][y]&& SEN_r_front_value < r_front_wall_judge) {//North & 直進。以下、普通の足立法
 LED2_y = 1;
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, 2000.0, V_search, V_search, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 direction_xy();

 LED2_y = 0;
 } else if (x < 15&& map2[x + 1][y]
 < map2[x][y]&& SEN_r_value < r_wall_judge) {	//North & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }
 LED1_p = 1;

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, 400.0, 1);
 direction_xy();
 LED1_p = 0;
 } else if (x > 0&& map2[x - 1][y]
 < map2[x][y]&& SEN_l_value < l_wall_judge) {	//North & 左折

 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 } else {
 if (direction_count == 0) {
 direction_count = 2;
 } else if (direction_count == 1) {
 direction_count = 3;
 } else if (direction_count == 2) {
 direction_count = 0;
 } else {
 direction_count = 1;
 }
 LED1_p = 1;

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 footmark[x][y] = 10;

 }
 break;

 case 1:
 if (x
 < 15&& hasReached(x+1,y)==0 && map2[x+1][y] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//East & 直進
 LED1_p = 1;
 LED3_r = 1;
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 direction_xy();
 LED1_p = 0;
 LED3_r = 0;

 } else if (y
 > 0&& hasReached(x,y-1)==0 && map2[x][y-1] < map2[x][y] && SEN_r_value < r_wall_judge) {//East & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (y
 < 15&& hasReached(x,y+1)==0 && map2[x][y+1] < map2[x][y] && SEN_l_value < l_wall_judge) {//East & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (x
 < 15&& map2[x+1][y] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//East & 直進。以下、普通の足立法
 LED1_p = 1;
 LED3_r = 1;
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 direction_xy();
 LED1_p = 0;
 LED3_r = 0;

 } else if (y
 > 0&& map2[x][y-1] < map2[x][y] && SEN_r_value < r_wall_judge) {//East & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (y
 < 15&& map2[x][y+1] < map2[x][y] && SEN_l_value < l_wall_judge) {//East & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else {
 if (direction_count == 0) {
 direction_count = 2;
 } else if (direction_count == 1) {
 direction_count = 3;
 } else if (direction_count == 2) {
 direction_count = 0;
 } else {
 direction_count = 1;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 footmark[x][y] = 10;

 }
 break;

 case 2:
 if (y
 > 0&& hasReached(x,y-1)==0 && map2[x][y-1] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 direction_xy();
 } else if (x
 > 0&& hasReached(x-1,y)==0 && map2[x-1][y] < map2[x][y] && SEN_r_value < r_wall_judge) {//South & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (x
 < 15&& hasReached(x+1,y)==0 && map2[x+1][y] < map2[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (y
 > 0&& map2[x][y-1] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進。以下、普通の足立法

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 direction_xy();
 } else if (x
 > 0&& map2[x-1][y] < map2[x][y] && SEN_r_value < r_wall_judge) {//South & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (x
 < 15&& map2[x+1][y] < map2[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else {
 if (direction_count == 0) {
 direction_count = 2;
 } else if (direction_count == 1) {
 direction_count = 3;
 } else if (direction_count == 2) {
 direction_count = 0;
 } else {
 direction_count = 1;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 footmark[x][y] = 10;

 }
 break;

 case 3:
 if (x
 > 0&& hasReached(x-1,y)==0 && map2[x-1][y] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進
 direction_xy();
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 } else if (y
 < 15&& hasReached(x,y+1)==0 && map2[x][y+1] < map2[x][y] && SEN_r_value < r_wall_judge) {//West & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (y
 > 0&& hasReached(x,y-1)==0 && map2[x][y-1] < map2[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (x
 > 0&& map2[x-1][y] < map2[x][y] && SEN_r_front_value < r_front_wall_judge) {//South & 直進。以下、普通の足立法
 direction_xy();
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(180.0, V_search, ACCEL_search, V_search, V_search, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 } else if (y
 < 15&& map2[x][y+1] < map2[x][y] && SEN_r_value < r_wall_judge) {//West & 右折
 if (direction_count == 3) {
 direction_count = 0;
 } else {
 direction_count++;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else if (y
 > 0&& map2[x][y-1] < map2[x][y] && SEN_l_value < l_wall_judge) {//West & 左折
 if (direction_count == 0) {
 direction_count = 3;
 } else {
 direction_count--;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_unclock3(90.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();

 } else {
 if (direction_count == 0) {
 direction_count = 2;
 } else if (direction_count == 1) {
 direction_count = 3;
 } else if (direction_count == 2) {
 direction_count = 0;
 } else {
 direction_count = 1;
 }

 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance_q(90.0, V_search, ACCEL_search, V_search, 150.0, 1,
 hikisuu_goal_x, hikisuu_goal_y);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 turn_clock3(180.0, V_search, ACCEL_search, 150.0, 150.0);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(STOP_count);
 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
 distance3(90.0, V_search, ACCEL_search, 150.0, V_search, 1);
 direction_xy();
 footmark[x][y] = 10;

 }
 break;

 }
 setReached(x, y);

 //		if (SEN_r_front_value > r_front_wall_judge) {	//前センサーの壁判断
 //			add_wall_front(x, y, direction_count);
 //		}
 //		if (SEN_r_value > r_wall_judge) {	//右センサーの壁判断
 //			add_wall_right(x, y, direction_count);
 //		}
 //		if (SEN_l_value > l_wall_judge) {	//左センサーの壁判断
 //			add_wall_left(x, y, direction_count);
 //		}
 if (x == hikisuu_goal_x && y == hikisuu_goal_y) {
 break;
 }

 }
 distance3(90.0, V_search, 2000.0, V_search, 150.0, 1);
 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
 wait(300);
 motor_enable = 0;
 }*/

void interrupt_cmt0() {		//割り込む関数
	flag_kabekire = 0;
	cmt_count++;
	if (PE.DRL.BIT.B12 == 0) {
		accident_flag = 1;
	}

	speed += accel * 0.001;
	total_dist += speed * 0.001;
	omega += angacc * 0.001;
	angle += omega * 0.001;

	SEN_r_diff = SEN_r_value - SEN_r_old_value;
	SEN_l_diff = SEN_l_value - SEN_l_old_value;

	SEN_r_old_value = SEN_r_value;		//最後でもいい気がする・・・
	SEN_l_old_value = SEN_l_value;		//最後でもいい気がする・・・

	/*	if (abs(SEN_r_diff) > DIFF_THRESHOLD) {			//壁切れ対策
	 r_threshold = SEN_r_ref + 10;  //変化量が一定以上なら、閾値を引き上げる
	 } else {
	 r_threshold = r_sen_thredhold; //変化量が一定以下なら、設定通りの閾値
	 }
	 if (abs(SEN_l_diff) > DIFF_THRESHOLD) {
	 l_threshold = SEN_l_ref + 10;  //変化量が一定以上なら、閾値を引き上げる
	 } else {
	 l_threshold = l_sen_thredhold; //変化量が一定以下なら、設定通りの閾値
	 }*/

	if (wall_control == 0) {
		speed_r = speed - (R_tread * omega);
		speed_l = speed + (R_tread * omega);
		TGRA_l = pi * l_tire_control_ON * 6.25 * 1000000.0 / (200.0 * speed_l);
		TGRA_r = pi * r_tire_control_ON * 6.25 * 1000000.0 / (200.0 * speed_r);
		count_kabekire_r = 4;
	} else if (wall_control == 1) {
		/*		if ((SEN_r_value > r_threshold+300) && (SEN_l_value > l_threshold+300)) {//壁読み//両方のセンサが使える時
		 switch (count_kabekire_r) {
		 case 0:	//両壁無し
		 flag_kabekire = 2;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 1: //両壁あり
		 break;
		 case 2: //左壁あり
		 flag_kabekire = 2;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 3: //右壁あり
		 flag_kabekire = 2;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 }
		 }else if ((SEN_r_value <= r_threshold-100) && (SEN_l_value <= l_threshold-50)) {	//両方のセンサが使えない時
		 switch (count_kabekire_r) {
		 case 0:
		 break;
		 case 1:
		 flag_kabekire = 1;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 2:
		 flag_kabekire = 1;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 3:
		 flag_kabekire = 1;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 }
		 count_kabekire_r = 0;			//両壁使えない場合
		 } else if (SEN_l_value <= l_threshold-50 && SEN_r_value > r_threshold+300) {	//右センサだけ使える時
		 switch (count_kabekire_r) {
		 case 0:
		 flag_kabekire = 2;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 1:
		 flag_kabekire = 1;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 2:
		 flag_kabekire = 2;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 3:
		 break;
		 }
		 count_kabekire_r = 3;			//右のみ使用可の場合
		 }else if(SEN_r_value <= r_threshold-100 && SEN_l_value > l_threshold+300){	//左センサだけ使える時
		 //			LED2_y = 1;
		 switch (count_kabekire_r) {
		 case 0:
		 flag_kabekire = 2;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 1:
		 flag_kabekire = 1;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 case 2:
		 break;
		 case 3:
		 flag_kabekire = 1;
		 interrupt_kabekire = interrupt_kabekire - 1;
		 break;
		 }
		 count_kabekire_r = 2;			//左のみ使用可の場合
		 }else{}*/

		if ((SEN_r_value > r_threshold) && (SEN_l_value > l_threshold)) {//壁読み壁制御開始
			//両方のセンサが使える時
			switch (count_kabekire_r) {
			case 0:	//両壁無し
				flag_kabekire = 20;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 1: //両壁あり
				break;
			case 2: //左壁あり
				flag_kabekire = 20;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 3: //右壁あり
				flag_kabekire = 2;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 4: //壁制御無しからの対応策
				break;
			}
			count_kabekire_r = 1;			//両壁の場合
			if (SEN_r_value > SEN_r_ref - 30 && SEN_r_value < SEN_r_ref + 30
					&& SEN_l_value > SEN_l_ref - 30
					&& SEN_l_value < SEN_l_ref + 30) {

				if (abs(SEN_r_diff) >= DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {//壁切れ対策,右壁の変化大のとき右制御をを切る
					Error = (float) (2 * (SEN_l_value - SEN_l_ref));
					Control = Kp_l * Error;
					LED2_y = 1;
					LED2_y = 0;
				} else if (abs(SEN_l_diff) >= DIFF_THRESHOLD
						&& abs(SEN_r_diff) < DIFF_THRESHOLD) {//壁切れ対策,左壁の変化大のとき左制御を切る
					Error = (float) (-2 * (SEN_r_value - SEN_r_ref));
					Control = Kp_r * Error;

				} else if (abs(SEN_r_diff) < DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {
					Error = (float) ((SEN_l_value - SEN_l_ref)
							- (SEN_r_value - SEN_r_ref));
					Control = Kp_center * Error;
				} else {
					Error = 0.0;
					//変化量が一定以下なら、設定通りの閾値
				}
			} else {
				Error = (float) ((SEN_l_value - SEN_l_ref)
						- (SEN_r_value - SEN_r_ref));
				Control = Kp_center * Error;
			}
//			LED2_y=0;

		} else if ((SEN_r_value <= r_threshold)
				&& (SEN_l_value <= l_threshold)) {
			//両方のセンサが使えない時
			Error = 0.0;
			Control = Kp_center * Error;
			switch (count_kabekire_r) {
			case 0:
				break;
			case 1:			//両壁あり
				flag_kabekire = 10;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 2:			//左壁あり
				flag_kabekire = 1;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 3:			//右壁あり
				flag_kabekire = 10;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 4: //壁制御無しからの対応策
				break;
			}
			count_kabekire_r = 0;			//両壁使えない場合

		} else if (SEN_l_value <= l_threshold && SEN_r_value > r_threshold) {
			//右センサだけ使える時
			switch (count_kabekire_r) {
			case 0:
				flag_kabekire = 20;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 1:
				flag_kabekire = 1;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 2:
				flag_kabekire = 20;	//このケースはあるのか…？
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 3:
				break;
			case 4: //壁制御無しからの対応策
				break;
			}
			count_kabekire_r = 3;			//右のみ使用可の場合

			if (SEN_r_value > SEN_r_ref - 30 && SEN_r_value < SEN_r_ref + 30) {
				if (abs(SEN_r_diff) >= DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {//壁切れ対策,右壁の変化大のとき右制御をを切る
					Error = 0.0;
					Control = Kp_r * Error;
				} else if (abs(SEN_l_diff) >= DIFF_THRESHOLD
						&& abs(SEN_r_diff) < DIFF_THRESHOLD) {//壁切れ対策,左壁の変化大のとき左制御を切る
					Error = (float) (-2 * (SEN_r_value - SEN_r_ref));
					Control = Kp_r * Error;

				} else if (abs(SEN_r_diff) < DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {
					Error = (float) (-2 * (SEN_r_value - SEN_r_ref));
					Control = Kp_r * Error;
				} else {
//				Error = (SEN_l_value - SEN_l_ref) - (SEN_r_value - SEN_r_ref);
					//変化量が一定以下なら、設定通りの閾値
//				Control = Kp_center * Error;
					Error = 0.0;
					Control = Kp_r * Error;
				}
			} else {
				Error = (float) (-2 * (SEN_r_value - SEN_r_ref));
				Control = Kp_r * Error;
				LED1_p = 1;
			}
			LED1_p = 0;
		} else {
			//左センサだけ使える時
//			LED2_y = 1;
			switch (count_kabekire_r) {
			case 0:
				flag_kabekire = 2;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 1:
				flag_kabekire = 10;
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 2:
				break;
			case 3:
				flag_kabekire = 10;	//このケースはあるのか…？
				interrupt_kabekire = interrupt_kabekire - 1;
				break;
			case 4: //壁制御無しからの対応策
				break;
			}
			count_kabekire_r = 2;			//左のみ使用可の場合

			if (SEN_l_value > SEN_l_ref - 30 && SEN_l_value < SEN_l_ref + 30) {
				if (abs(SEN_r_diff) >= DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {//壁切れ対策,右壁の変化大のとき右制御をを切る
					Error = (float) (2 * (SEN_l_value - SEN_l_ref));
					Control = Kp_l * Error;

				} else if (abs(SEN_l_diff) >= DIFF_THRESHOLD
						&& abs(SEN_r_diff) < DIFF_THRESHOLD) {//壁切れ対策,左壁の変化大のとき左制御を切る
					Error = 0.0;
					Control = Kp_r * Error;
				} else if (abs(SEN_r_diff) < DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {
					Error = (float) (2 * (SEN_l_value - SEN_l_ref));
					Control = Kp_l * Error;

				} else {					//両方の壁制御を切る
//				Error = (SEN_l_value - SEN_l_ref) - (SEN_r_value - SEN_r_ref);
				//変化量が一定以下なら、設定通りの閾値
//				Control = Kp_center * Error;
					Error = 0.0;
					Control = Kp_center * Error;
				}
			} else {
				Error = (float) (2 * (SEN_l_value - SEN_l_ref));
				Control = Kp_l * Error;
			}

//			LED2_y = 0;
		}
		if (speed <= 200) {
			Control = 0;
		}
		if (speed >= 200 && speed < 300) {

		}
		speed_r = speed - Control;
		speed_l = speed + Control;
		TGRA_l = pi * l_tire * 6.25 * 1000000 / (200 * speed_l);
		TGRA_r = pi * r_tire * 6.25 * 1000000 / (200 * speed_r);
	}

	/*	Control = Kp * Error;
	 speed_r = speed - Control;
	 speed_l = speed + Control;
	 TGRA_l = pi * l_tire * 6.25 * 1000000 / (200 * speed_l);
	 TGRA_r = pi * r_tire * 6.25 * 1000000 / (200 * speed_r);*/

	sen_AD_convert();
	CMT0.CMCSR.BIT.CMF = 0;		//フラグクリア
}
void interrupt_cmt1() {		//cmt0の内容の保存
	flag_kabekire = 0;
	cmt_count++;
	if (PE.DRL.BIT.B12 == 0) {
		accident_flag = 1;
	}

	speed += accel * 0.001;
	total_dist += speed * 0.001;
	omega += angacc * 0.001;
	angle += omega * 0.001;

	SEN_r_diff = SEN_r_value - SEN_r_old_value;
	SEN_l_diff = SEN_l_value - SEN_l_old_value;

	SEN_r_old_value = SEN_r_value;		//最後でもいい気がする・・・
	SEN_l_old_value = SEN_l_value;		//最後でもいい気がする・・・

	/*	if (abs(SEN_r_diff) > DIFF_THRESHOLD) {			//壁切れ対策
	 r_threshold = SEN_r_ref + 10;  //変化量が一定以上なら、閾値を引き上げる
	 } else {
	 r_threshold = r_sen_thredhold; //変化量が一定以下なら、設定通りの閾値
	 }
	 if (abs(SEN_l_diff) > DIFF_THRESHOLD) {
	 l_threshold = SEN_l_ref + 10;  //変化量が一定以上なら、閾値を引き上げる
	 } else {
	 l_threshold = l_sen_thredhold; //変化量が一定以下なら、設定通りの閾値
	 }*/

	if (wall_control == 0) {
		speed_r = speed - (R_tread * omega);
		speed_l = speed + (R_tread * omega);
		TGRA_l = pi * l_tire_control_ON * 6.25 * 1000000.0 / (200.0 * speed_l);
		TGRA_r = pi * r_tire_control_ON * 6.25 * 1000000.0 / (200.0 * speed_r);
	} else if (wall_control == 1) {
		if ((SEN_r_value > r_threshold) && (SEN_l_value > l_threshold)) {//壁読み
			//両方のセンサが使える時
			if (SEN_r_value > SEN_r_ref - 30 && SEN_r_value < SEN_r_ref + 30
					&& SEN_l_value > SEN_l_ref - 30
					&& SEN_l_value < SEN_l_ref + 30) {
				if (abs(SEN_r_diff) >= DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {//壁切れ対策,右壁の変化大のとき右制御をを切る
					Error = (float) (2 * (SEN_l_value - SEN_l_ref));
					Control = Kp_l * Error;

					LED2_y = 1;

					/*					count_kabekire_r = count_kabekire_r + 1;//壁切れ処理開始！
					 if (count_kabekire_r > 1 && abs(SEN_r_diff) >= 40) {
					 count_kabekire_r = count_kabekire_r + 1;
					 }
					 if (SEN_r_value < r_threshold && count_kabekire_r > 0) {	//壁切れ補正　Ⅰ壁あり→壁無し
					 LED2_y = 1;
					 flag_kabekire = 1;
					 count_kabekire_r = 0;
					 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ(モーター回転開始)
					 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ(モーター回転開始)

					 //						for(i=0;i<300;i++){
					 //						}
					 //						LED2_y = 0;
					 }else if (SEN_r_value > r_threshold && count_kabekire_r > 200){//壁切れ補正　Ⅱ壁無し→壁あり
					 LED1_p = 1;
					 flag_kabekire = 2;
					 count_kabekire_r = 0;
					 //						for(i=0;i<300;i++){
					 //						}
					 LED1_p = 0;
					 }*/
					LED2_y = 0;

				} else if (abs(SEN_l_diff) >= DIFF_THRESHOLD
						&& abs(SEN_r_diff) < DIFF_THRESHOLD) {//壁切れ対策,左壁の変化大のとき左制御を切る
					Error = (float) (-2 * (SEN_r_value - SEN_r_ref));
					Control = Kp_r * Error;

				} else if (abs(SEN_r_diff) < DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {
					Error = (float) ((SEN_l_value - SEN_l_ref)
							- (SEN_r_value - SEN_r_ref));
					Control = Kp_center * Error;
					count_kabekire_r = 0;			//壁切れ読まない処理
				} else {
					Error = 0.0;
					//変化量が一定以下なら、設定通りの閾値

				}
			} else {
				Error = (float) ((SEN_l_value - SEN_l_ref)
						- (SEN_r_value - SEN_r_ref));
				Control = Kp_center * Error;
			}
		} else if ((SEN_r_value <= r_threshold)
				&& (SEN_l_value <= l_threshold)) {
			//両方のセンサが使えない時
			Error = 0.0;
			Control = Kp_center * Error;
		} else if (SEN_l_value <= l_threshold && SEN_r_value > r_threshold) {
			//右センサだけ使える時
			if (SEN_r_value > SEN_r_ref - 30
					&& SEN_r_value
							< SEN_r_ref
									+ 30
									/*&&SEN_l_value > SEN_l_ref - 30 && SEN_l_value < SEN_l_ref + 30*/) {
				if (abs(SEN_r_diff) >= DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {//壁切れ対策,右壁の変化大のとき右制御をを切る
					Error = 0.0;
					Control = Kp_r * Error;
				} else if (abs(SEN_l_diff) >= DIFF_THRESHOLD
						&& abs(SEN_r_diff) < DIFF_THRESHOLD) {//壁切れ対策,左壁の変化大のとき左制御を切る
					Error = (float) (-2 * (SEN_r_value - SEN_r_ref));
					Control = Kp_r * Error;

				} else if (abs(SEN_r_diff) < DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {
					Error = (float) (-2 * (SEN_r_value - SEN_r_ref));
					Control = Kp_r * Error;
				} else {
//				Error = (SEN_l_value - SEN_l_ref) - (SEN_r_value - SEN_r_ref);
					//変化量が一定以下なら、設定通りの閾値
//				Control = Kp_center * Error;
					Error = 0.0;
					Control = Kp_r * Error;
				}
			} else {
				Error = (float) (-2 * (SEN_r_value - SEN_r_ref));
				Control = Kp_r * Error;
				LED1_p = 1;
			}
			LED1_p = 0;
		} else {
			//左センサだけ使える時
//			LED2_y = 1;
			if (SEN_l_value > SEN_l_ref - 30 && SEN_l_value < SEN_l_ref + 30) {
				if (abs(SEN_r_diff) >= DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {//壁切れ対策,右壁の変化大のとき右制御をを切る
					Error = (float) (2 * (SEN_l_value - SEN_l_ref));
					Control = Kp_l * Error;
					LED3_r = 1;
					count_kabekire_r = count_kabekire_r + 1;		//壁切れ処理開始！
					if (count_kabekire_r > 1 && abs(SEN_r_diff) >= 40) {
						count_kabekire_r = count_kabekire_r + 1;
					}
					if (SEN_r_value < r_threshold
							&& count_kabekire_r > 2 * 100) {	//壁切れ補正　Ⅰ壁あり→壁無し
						LED2_y = 1;
						flag_kabekire = 1;
						count_kabekire_r = 0;
//						for(i=0;i<300;i++){
//						}
						LED2_y = 0;
					} else if (SEN_r_value > r_threshold
							&& count_kabekire_r > 2 * 100) {	//壁切れ補正　Ⅱ壁無し→壁あり
						LED1_p = 1;
						flag_kabekire = 2;
						count_kabekire_r = 0;
//						for(i=0;i<300;i++){
//						}
						LED1_p = 0;
					}
					LED3_r = 0;

				} else if (abs(SEN_l_diff) >= DIFF_THRESHOLD
						&& abs(SEN_r_diff) < DIFF_THRESHOLD) {//壁切れ対策,左壁の変化大のとき左制御を切る
					Error = 0.0;
					Control = Kp_r * Error;
				} else if (abs(SEN_r_diff) < DIFF_THRESHOLD
						&& abs(SEN_l_diff) < DIFF_THRESHOLD) {
					Error = (float) (2 * (SEN_l_value - SEN_l_ref));
					Control = Kp_l * Error;
					count_kabekire_r = 0;					//壁切れ読まない処理

				} else {					//両方の壁制御を切る
//				Error = (SEN_l_value - SEN_l_ref) - (SEN_r_value - SEN_r_ref);
				//変化量が一定以下なら、設定通りの閾値
//				Control = Kp_center * Error;
					Error = 0.0;
					Control = Kp_center * Error;
				}
			} else {
				Error = (float) (2 * (SEN_l_value - SEN_l_ref));
				Control = Kp_l * Error;
				count_kabekire_r = 0;					//壁切れ読まない処理
//				LED2_y = 1;
			}

//			LED2_y = 0;
		}
		if (speed <= 200) {
			Control = 0;
		}
		if (speed >= 200 && speed < 300) {

		}
		speed_r = speed - Control;
		speed_l = speed + Control;
		TGRA_l = pi * l_tire * 6.25 * 1000000 / (200 * speed_l);
		TGRA_r = pi * r_tire * 6.25 * 1000000 / (200 * speed_r);
	}

	/*	Control = Kp * Error;
	 speed_r = speed - Control;
	 speed_l = speed + Control;
	 TGRA_l = pi * l_tire * 6.25 * 1000000 / (200 * speed_l);
	 TGRA_r = pi * r_tire * 6.25 * 1000000 / (200 * speed_r);*/

	sen_AD_convert();
	CMT0.CMCSR.BIT.CMF = 0;		//フラグクリア
}
void main(void) {
	PFC.PBIORL.BIT.B1 = 1;
	PFC.PBIORL.BIT.B2 = 1;
	PFC.PBIORL.BIT.B3 = 1;
	PFC.PEIORL.BIT.B8 = 1;
	PFC.PAIORL.BIT.B12 = 1;
	PFC.PAIORL.BIT.B13 = 1;
	PFC.PAIORL.BIT.B14 = 1;
	PFC.PAIORL.BIT.B15 = 1;
	PFC.PEIORL.BIT.B0 = 1;
	PFC.PEIORL.BIT.B1 = 1;
	PFC.PEIORL.BIT.B2 = 1;
	PFC.PEIORL.BIT.B4 = 1;
	PFC.PEIORL.BIT.B5 = 1;
	PFC.PEIORL.BIT.B10 = 0;
	PFC.PEIORL.BIT.B11 = 0;
	PFC.PEIORL.BIT.B12 = 0;
	initCPU();
	initMTU();
	initCMT();
	initAD();
	init_sci();				//teratermの使い方確認
	Battery_AD_convert();
	if (Battery < 11.0) {
		while (1) {
			LED1_p = 1;
			LED2_y = 0;
			LED3_r = 0;
			for (k = 0; k <= 100000; k++) {
			}
			LED1_p = 0;
			LED2_y = 1;
			LED3_r = 0;
			for (k = 0; k <= 100000; k++) {
			}
			LED1_p = 0;
			LED2_y = 0;
			LED3_r = 1;
			for (k = 0; k <= 100000; k++) {
			}
		}
	} else if (Battery >= 11.0) {

//		motor_enable = 1;
//		wait(300); 			//励磁直後は少し待つ！
		PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		PE.DRL.BIT.B4 = 1;	//B4=1で正回転*/
		//	MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
		//	MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
		while (1) {
			accident_flag = 0;
			clash_count = 0;

			mode_select();
			CMT.CMSTR.BIT.STR0 = 1;		// ステータスレジスタ　0：カウント停止, 1：カウント開始
			CMT.CMSTR.BIT.STR1 = 1;		// ステータスレジスタ　0：カウント停止, 1：カウント開始
			task_select();
			CMT.CMSTR.BIT.STR0 = 0;		// ステータスレジスタ　0：カウント停止, 1：カウント開始
			CMT.CMSTR.BIT.STR1 = 0;		// ステータスレジスタ　0：カウント停止, 1：カウント開始

		}
		//	hidaritehou2();
		/* 	wall_control = 1;		//連続的な加減速
		 motor_enable = 1;
		 wait(300); 			//励磁直後は少し待つ！
		 MTU2.TSTR.BIT.CST0 = 1;		//ステータスレジスタ(モーター回転開始)
		 MTU2.TSTR.BIT.CST1 = 1;		//ステータスレジスタ(モーター回転開始)
		 distance3(1000.0, 1000.0, 500.0, 150.0, 400.0);
		 distance3(800.0, 1000.0, 500.0, 400.0, 150.0);
		 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		 wait(500);
		 motor_enable = 0;*/

		//	sen_AD_display();
		//	distance2(90.0, 250.0, 500.0, 150.0);
		/*	while(1){
		 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
		 distance3(90.0, 400.0, 1500.0, 150.0, 150.0, 0);
		 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		 wait(500);
		 turn_unclock3(90.0, 400.0, 1000.0, 150.0, 150.0);
		 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		 PE.DRL.BIT.B0 = 0;	//B0=0で正回転
		 PE.DRL.BIT.B4 = 1;	//B4=1で正回転
		 wall_control = 1;
		 distance3(90.0, 400.0, 1500.0, 150.0, 400.0,0);
		 distance3(180.0,400.0, 1500.0, 400.0, 150.0,0);
		 MTU2.TSTR.BIT.CST0 = 0;		//ステータスレジスタ　停止
		 MTU2.TSTR.BIT.CST1 = 0;		//ステータスレジスタ　停止
		 wait(2000);
		 }*/

		/*	wall_control = 1;
		 distance(1260.0, 400.0, 400.0);  //ほぼ調整完了*/

		//	distance(900.0, 500.0, 2000.0);  //ほぼ調整完了
		//	wait(2000);
		/*	while (i < 21)      //ちょい調整中…
		 {
		 i++;
		 turn(180, 600, 500);
		 wait(2000);
		 }*/

		//	distance2(1000,1000,750,200);
		/*	 while (1) {				//Battery　AD変換
		 init_sci();				//teratermの使い方確認
		 //		myprintf("kabocha\n");

		 initAD();
		 AD0.ADCR.BIT.ADST = 0;	//BatteryのAD変換
		 AD0.ADCSR.BIT.CH = 0;
		 AD0.ADCR.BIT.ADST = 1;
		 while (AD0.ADCSR.BIT.ADF == 0)
		 ;
		 AD0.ADCSR.BIT.ADF = 0;

		 SEN = AD0.ADDR0 >> 6;
		 Battery = 5 * 151 / 51 * SEN / 1024;
		 myprintf("電圧値=%f\n\r", Battery);
		 wait(100);
		 }*/

		/*	initCMT();
		 CMT.CMSTR.BIT.STR0 = 1;	// ステータスレジスタ　0：カウント停止, 1：カウント開始
		 PB.DR.BIT.B3=1;

		 while(1)
		 {
		 PB.DR.BIT.B1 = 1;
		 PB.DR.BIT.B2 = 0;
		 wait(1000);
		 PB.DR.BIT.B1 = 0;
		 PB.DR.BIT.B2 = 1;
		 wait(1000);
		 }*/

		/*while(1){				//LED点滅
		 while (i < 1000000) {
		 i++;
		 PB.DR.BIT.B1 = 1;
		 PB.DR.BIT.B2 = 1;
		 PB.DR.BIT.B3 = 1;
		 }
		 while (i > 0) {
		 i--;
		 PB.DR.BIT.B1 = 0;
		 PB.DR.BIT.B2 = 0;
		 PB.DR.BIT.B3 = 0;
		 }
		 }*/
		/*	while (1) {
		 if ( PE.DRL.BIT.B10 == 0) {		//スイッチ押すとLED点灯,離すと消灯
		 PB.DR.BIT.B1 = 1;
		 } else {
		 PB.DR.BIT.B1 = 0;
		 }
		 if ( PE.DRL.BIT.B11 == 0) {
		 PB.DR.BIT.B2 = 1;
		 } else {
		 PB.DR.BIT.B2 = 0;
		 }
		 if ( PE.DRL.BIT.B12 == 0) {
		 PB.DR.BIT.B3 = 1;
		 } else {
		 PB.DR.BIT.B3 = 0;
		 }
		 }*/

	}

}
